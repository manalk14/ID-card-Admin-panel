<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional ID Card Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
  
<style>
      * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100%;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: flex-start; 
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            overflow-y: auto;
            padding: 20px;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-container {
            background: linear-gradient(135deg, #1e293b 0%, #374151 100%);
            border-radius: 24px;
            padding: 32px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
            margin: 40px auto;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-container .modal-header {
            margin-bottom: 24px;
        }

        .modal-container .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
        }

        .modal-container .modal-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .modal-container .form-group {
            margin-bottom: 20px;
        }

        .modal-container .form-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
        }

        .modal-container .required-indicator {
            color: #ef4444;
        }

        .modal-container .form-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
        }

        .modal-container .form-input:focus {
            border-color: #a78bfa;
            box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
        }

        .modal-container .form-input.error {
            border-color: #ef4444;
        }

        .modal-container .error-message {
            font-size: 12px;
            color: #ef4444;
            margin-top: 4px;
            display: none;
        }

        .modal-container .error-message.show {
            display: block;
        }

        .modal-container .form-requirements {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
        }

        .modal-container .requirements-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            margin-bottom: 8px;
        }

        .modal-container .requirement-item {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .modal-container .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-container .modal-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .modal-container .modal-btn.cancel {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .modal-container .modal-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-container .modal-btn.save {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .modal-container .modal-btn.save:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }

        .modal-container .modal-btn.save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            min-width: 320px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 24px;
            overflow-y: auto;
            height: 100vh;
            position: relative;
            z-index: 10;
        }

        .sidebar h1 {
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 32px;
            background: linear-gradient(135deg, #a78bfa, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .section {
            margin-bottom: 24px;
        }

        .section-label {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .side-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 24px;
        }

        .side-btn {
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .side-btn.active {
            background: linear-gradient(135deg, #a78bfa, #ec4899);
            color: white;
            box-shadow: 0 8px 20px rgba(167, 139, 250, 0.4);
        }

        .side-btn:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
        }

        .side-btn:not(.active):hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .orientation-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .orientation-btn {
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
        }

        .orientation-btn.active {
            background: #10b981;
            color: white;
        }

        .orientation-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .input-group {
            display: flex;
            gap: 8px;
        }

        input[type="text"] {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.2s ease;
        }

        input[type="text"]:focus {
            border-color: #a78bfa;
            box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .add-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #a78bfa, #ec4899);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-btn:hover {
            box-shadow: 0 8px 20px rgba(167, 139, 250, 0.4);
            transform: translateY(-2px);
        }

        .file-upload-btn {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            display: block;
        }

        .file-upload-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="color"] {
            width: 100%;
            height: 48px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            outline: none;
        }

        select option {
            background: #1e293b;
            color: white;
        }

        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
        }

        /* Main Canvas Area */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow: hidden;
            height: 100vh;
            min-width: 0;
        }

        .canvas-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            width: 100%;
            max-width: 1000px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            flex-shrink: 0;
        }

        .undo-redo-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-size: 14px;
        }

        .undo-redo-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .side-indicator {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            font-weight: 600;
            white-space: nowrap;
            font-size: 14px;
        }

        /* Zoom Controls */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 8px;
            white-space: nowrap;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .zoom-level {
            color: white;
            font-weight: 600;
            font-size: 14px;
            min-width: 50px;
            text-align: center;
        }

        /* Canvas content area */
        .canvas-content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            width: 100%;
            padding: 5px;
            overflow-y: auto;
            min-height: 0;
        }

        .canvas-wrapper {
            transition: transform 0.3s ease;
            transform-origin: center center;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .canvas {
            position: relative;
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        /* Vertical canvas specific */
        .canvas.vertical-canvas {
            max-height: 700px;
            margin: 10px auto;
        }

        .canvas-element {
            position: absolute;
            cursor: move;
            user-select: none;
        }

        .canvas-element.selected {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .canvas-element img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }

        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 10;
        }

        .resize-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }

        .resize-handle.ne {
            top: -6px;
            right: -6px;
            cursor: ne-resize;
        }

        .resize-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }

        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        /* Download controls section */
        .download-controls-section {
            width: 70%;
            max-width: 1000px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            margin-top: 10px;
            flex-shrink: 0;
        }

        /* Quality Selector */
        .quality-selector {
            margin-bottom: 15px;
            width: 100%;
        }

        .quality-label {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quality-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 12px;
        }

        .quality-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .quality-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
            border: 2px solid white;
        }

        .quality-value {
            color: white;
            font-weight: 600;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }

        /* Download Options */
        .download-options {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .download-option-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            white-space: nowrap;
            flex: 1;
            min-width: 120px;
        }

        .download-option-btn.both {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .download-option-btn.front {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .download-option-btn.back {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .download-option-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .range-value {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-align: right;
            margin-top: 4px;
        }

        /* Right Panel */
        .right-panel {
            width: 320px;
            min-width: 320px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 24px;
            height: 100vh;
            position: relative;
            z-index: 10;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
        }

        .panel h3 {
            font-size: 18px;
            margin-bottom: 16px;
            color: white;
        }

        .property-group {
            margin-bottom: 16px;
        }

        .property-label {
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
        }

        .style-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .style-btn {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 60px;
        }

        .style-btn.active {
            background: #3b82f6;
            color: white;
        }

        .style-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .action-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
        }

        .action-btn.duplicate {
            background: #3b82f6;
            color: white;
        }

        .action-btn.delete {
            background: #ef4444;
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .layer-item {
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .layer-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .layer-item.selected {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }

        .layer-info {
            flex: 1;
            min-width: 0;
        }

        .layer-icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .layer-name {
            font-size: 14px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-type {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: capitalize;
        }

        .layer-delete {
            padding: 6px;
            background: rgba(239, 68, 68, 0.2);
            border: none;
            border-radius: 6px;
            color: #ef4444;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .layer-delete:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
        }

        .hidden {
            display: none !important;
        }

        /* Canvas Size Section */
        .section label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 6px;
        }

        .section input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
            outline: none;
            transition: all 0.25s ease;
        }

        /* Remove number arrows */
        .section input[type="number"]::-webkit-inner-spin-button,
        .section input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .section input[type="number"]:focus {
            border-color: #a78bfa;
            box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.15);
        }

        /* Apply Size Button */
        .size-apply-btn {
            width: 100%;
            margin-top: 8px;
            padding: 12px;
            border-radius: 10px;
            background: linear-gradient(135deg, #a78bfa, #ec4899);
            color: #ffffff;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.25s ease;
            border: none;
        }

        .size-apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(167, 139, 250, 0.45);
        }

        .size-apply-btn:active {
            transform: scale(0.97);
        }

        .mt-5 {
            margin-top: 20px;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #10b981;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .loading-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Size Warning */
        .size-warning {
            color: #fbbf24;
            font-size: 12px;
            margin-top: 8px;
            text-align: center;
            display: none;
        }

        /* New Features Styles */
        .advanced-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .advanced-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            flex: 1;
        }

        .advanced-btn.active {
            background: #8b5cf6;
            color: white;
            border-color: #8b5cf6;
        }

        .advanced-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .color-picker-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 80px;
        }

        /* Radio button styles for export modal */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 8px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.2s ease;
        }

        .radio-option:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: #a78bfa;
        }

        .radio-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .radio-option.selected {
            background: rgba(167, 139, 250, 0.2);
            border: 1px solid rgba(167, 139, 250, 0.5);
        }

        /* Edit mode styles */
        .edit-mode-banner {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 10px;
            display: none;
        }

        .edit-mode-banner.show {
            display: block;
        }

        /* Update template button */
        .update-template-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .update-template-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4);
        }

        /* Back button */
        .backbtn {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            margin-bottom: 20px;
        }

        .backbtn:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
        }

        .backbtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .app-container {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
                overflow-y: auto;
            }

            .sidebar,
            .right-panel {
                width: 100%;
                min-width: 100%;
                height: auto;
                max-height: 400px;
            }

            .sidebar {
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .right-panel {
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }

            .canvas-container {
                height: auto;
                min-height: 70vh;
            }
            
            .canvas-header {
                padding: 8px 10px;
                gap: 8px;
            }
            
            .undo-redo-btn, .side-indicator, .zoom-controls {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .zoom-btn {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
            
            .download-options {
                gap: 8px;
            }
            
            .download-option-btn {
                padding: 10px 15px;
                font-size: 12px;
                min-width: 100px;
            }
        }
</style>
</head>

<body>
    <!-- Modal Overlay - User Info Modal -->
    <div class="modal-overlay" id="userInfoModal">
        <div class="modal-container">
            <div class="modal-header">
                <h2 class="modal-title">User Information</h2>
                <p class="modal-subtitle">Please provide your details before downloading</p>
            </div>

            <div class="form-group">
                <label class="form-label">Full Name <span class="required-indicator">*</span></label>
                <input type="text" class="form-input" id="fullNameInput" placeholder="Enter your full name">
                <div class="error-message" id="nameError">Full name is required (minimum 3 characters)</div>
            </div>

            <div class="form-group">
                <label class="form-label">Phone Number <span class="required-indicator">*</span></label>
                <input type="text" class="form-input" id="phoneInput" placeholder="Enter your phone number">
                <div class="error-message" id="phoneError">Valid phone number is required (10-15 digits)</div>
            </div>

            <div class="form-group">
                <label class="form-label">Address <span class="required-indicator">*</span></label>
                <input type="text" class="form-input" id="addressInput" placeholder="Enter your full address">
                <div class="error-message" id="addressError">Address is required (minimum 10 characters)</div>
            </div>

            <div class="form-requirements">
                <div class="requirements-title">Requirements:</div>
                <div class="requirement-item">Full Name: Minimum 3 characters</div>
                <div class="requirement-item">Phone: 10-15 digits only</div>
                <div class="requirement-item">Address: Minimum 10 characters</div>
                <div class="requirement-item">All fields are required</div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeUserModal()">Cancel</button>
                <button class="modal-btn save" id="saveBtn" onclick="saveUserInfo()" disabled>Save & Download</button>
            </div>
        </div>
    </div>

    <!-- Export Elements Modal -->
    <div class="modal-overlay" id="exportElementsModal">
        <div class="modal-container">
            <div class="modal-header">
                <h2 class="modal-title" id="exportModalTitle">Export Elements</h2>
                <p class="modal-subtitle" id="exportModalSubtitle">Configure export settings and send to API</p>
            </div>

            <div class="form-group">
                <label class="form-label">Template Name <span class="required-indicator">*</span></label>
                <input type="text" class="form-input" id="templateNameInput" placeholder="Enter template name">
                <div class="error-message" id="templateNameError">Template name is required</div>
            </div>

            <div class="form-group">
                <label class="form-label">Service <span class="required-indicator">*</span></label>
                <select class="form-input" id="serviceSelect">
                    <option value="">Select a service</option>
                    <option value="ID Card">ID Card</option>
                    <option value="Momentos">Momentos</option>
                    <option value="Lanyard">Lanyard</option>
                    <option value="Certificates">Certificates</option>
                </select>
                <div class="error-message" id="serviceError">Please select a service</div>
            </div>

            <div class="form-group">
                <label class="form-label">Access Type <span class="required-indicator">*</span></label>
                <div class="radio-group" id="accessTypeGroup">
                    <label class="radio-option" onclick="selectRadio(this)">
                        <input type="radio" name="accessType" value="all">
                        <span class="radio-label">All</span>
                    </label>
                    <label class="radio-option" onclick="selectRadio(this)">
                        <input type="radio" name="accessType" value="dealer">
                        <span class="radio-label">Dealer</span>
                    </label>
                </div>
                <div class="error-message" id="accessTypeError">Please select an access type</div>
            </div>

            <div class="form-group">
                <label class="form-label">Export Type <span class="required-indicator">*</span></label>
                <div class="radio-group">
                    <label class="radio-option" onclick="selectExportType(this)">
                        <input type="radio" name="exportType" value="both" checked>
                        <span class="radio-label">Both Sides</span>
                    </label>
                    <label class="radio-option" onclick="selectExportType(this)">
                        <input type="radio" name="exportType" value="front">
                        <span class="radio-label">Front Only</span>
                    </label>
                    <label class="radio-option" onclick="selectExportType(this)">
                        <input type="radio" name="exportType" value="back">
                        <span class="radio-label">Back Only</span>
                    </label>
                </div>
            </div>

            <div class="form-requirements">
                <div class="requirements-title" id="exportRequirementsTitle">Export Information:</div>
                <div class="requirement-item">Template Name: Used to identify your template</div>
                <div class="requirement-item">Service: The category for this template</div>
                <div class="requirement-item">Access Type: Determines who can access this template</div>
                <div class="requirement-item">Data will be sent to API and downloaded locally</div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeExportElementsModal()">Cancel</button>
                <button class="modal-btn save" id="exportElementsBtn" onclick="handleExportClick(event)">Export & Download</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing</div>
        <div class="loading-details" id="loadingDetails">Please wait...</div>
    </div>

    <div class="app-container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <!-- Edit Mode Banner -->
            <div class="edit-mode-banner" id="editModeBanner">
                ‚úèÔ∏è Edit Mode - Template ID: <span id="templateIdDisplay"></span>
            </div>
            
            <h1 id="appTitle">ID Card Editor</h1>

            <!-- Side Toggle -->
            <div class="side-toggle">
                <button class="side-btn active" id="frontSideBtn" onclick="switchSide('front')">Front</button>
                <button class="side-btn" id="backSideBtn" onclick="switchSide('back')">Back</button>
            </div>

            <!-- Zoom Controls -->
            <div class="section">
                <div class="section-label">üîç Canvas Zoom</div>
                <div class="zoom-controls" style="justify-content: center;">
                    <button class="zoom-btn" id="zoomOutBtn" onclick="zoomOut()">‚àí</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" id="zoomInBtn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">‚Ü∫</button>
                </div>
            </div>

            <!-- Border Radius Style -->
            <div class="section">
                <div class="section-label">‚≠ï Border Radius</div>
                <input type="range" min="0" max="40" value="20" id="radiusRange" oninput="updateRadius(this.value)">
                <div class="range-value">
                    <span id="radiusValue">20</span> px
                </div>
            </div>

            <!-- Orientation Toggle -->
            <div class="section mt-5">
                <div class="section-label">üìê Card Orientation</div>
                <div class="orientation-toggle">
                    <button class="orientation-btn active" id="horizontalBtn" onclick="setOrientation('horizontal')">
                        üóìÔ∏è Horizontal
                    </button>
                    <button class="orientation-btn" id="verticalBtn" onclick="setOrientation('vertical')">
                        üì± Vertical
                    </button>
                </div>
            </div>

            <!-- Canvas Size Section -->
            <div class="section">
                <div class="section-label">üìè Canvas Size</div>
                <div class="input-group">
                    <input type="number" id="canvasWidth" value="700" min="100" max="10000">
                    <input type="number" id="canvasHeight" value="450" min="100" max="10000">
                </div>
                <button class="size-apply-btn" onclick="applyCanvasSize()">Apply Size</button>
                <div class="size-warning" id="sizeWarning">Large sizes will increase file size significantly</div>
            </div>

            <!-- Add Text -->
            <div class="section">
                <div class="section-label">üìù Add Text</div>
                <div class="input-group">
                    <input type="text" id="textInput" placeholder="Enter text..."
                        onkeypress="if(event.key==='Enter')addCustomText()">
                    <button class="add-btn" onclick="addCustomText()">+</button>
                </div>
            </div>

            <!-- Add Image -->
            <div class="section">
                <div class="section-label">üñºÔ∏è Add Image</div>
                <label class="file-upload-btn">
                    Upload Image
                    <input type="file" accept="image/*" onchange="addImage(event)" style="display: none;">
                </label>
            </div>

            <!-- QR Code -->
            <div class="section">
                <div class="section-label">üì± QR Code</div>
                <div class="input-group">
                    <input type="text" id="qrInput" placeholder="QR data..."
                        onkeypress="if(event.key==='Enter')addQRCode()">
                    <button class="add-btn" onclick="addQRCode()">+</button>
                </div>
            </div>

            <!-- Barcode -->
            <div class="section">
                <div class="section-label">‚¨ú Barcode</div>
                <div class="input-group">
                    <input type="text" id="barcodeInput" placeholder="Barcode data..."
                        onkeypress="if(event.key==='Enter')addBarcode()">
                    <button class="add-btn" onclick="addBarcode()">+</button>
                </div>
            </div>

            <!-- Canvas Background -->
            <div class="section">
                <div class="section-label">üé® Canvas Background</div>
                <input type="color" id="bgColorInput" value="#ffffff" onchange="changeCanvasBackground()">
            </div>

            <!-- JSON Operations -->
            <div class="section">
                <div class="section-label">üîÑ Export Elements</div>
                <div class="input-group">
                    <button class="add-btn" id="exportElementsMainBtn" onclick="showExportElementsModal()" style="width: 100%; margin: 4px;">Export Elements</button>
                    <button class="update-template-btn" id="updateTemplateBtn" onclick="showUpdateTemplateModal()" style="width: 100%; margin: 4px; display: none;">Update Template</button>
                </div>
            </div>

            <!-- Import Project Button -->
            <div class="section">
                <div class="section-label">üìÅ Import Project</div>
                <label class="file-upload-btn">
                    Import JSON Project
                    <input type="file" accept=".json" onchange="importProject(event)" style="display: none;">
                </label>
            </div>

            <!-- Background Image -->
            <div class="section">
                <div class="section-label">Background Image</div>
                <label class="file-upload-btn">
                    Upload Background
                    <input type="file" accept="image/*" onchange="addBackgroundImage(event)" style="display: none;">
                </label>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container">
            <!-- Canvas Header -->
            <div class="canvas-header">
                <button class="undo-redo-btn" id="undoBtn" onclick="undo()" disabled>‚Ü∂ Undo</button>
                <button class="undo-redo-btn" id="redoBtn" onclick="redo()" disabled>‚Ü∑ Redo</button>
                <div class="side-indicator" id="sideIndicator">üìÑ Front Side</div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOutBtn" onclick="zoomOut()">‚àí</button>
                    <span class="zoom-level" id="zoomLevel">100%</span>
                    <button class="zoom-btn" id="zoomInBtn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">‚Ü∫</button>
                </div>
            </div>

            <!-- Canvas Content Area -->
            <div class="canvas-content-wrapper">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <div id="frontCanvas" class="canvas"></div>
                    <div id="backCanvas" class="canvas hidden"></div>
                </div>
            </div>

            <!-- Download Controls Section -->
            <div class="download-controls-section">
                <!-- Quality Selector -->
                <div class="quality-selector">
                    <div class="quality-label">üéØ Download Quality</div>
                    <div class="quality-slider-container">
                        <input type="range" min="1" max="20" value="4" class="quality-slider" id="qualitySlider"
                            oninput="updateQualityValue()">
                        <span class="quality-value" id="qualityValue">4x</span>
                    </div>
                    <div class="range-value">
                        <span id="estimatedSize">Estimated: ~2 MB</span>
                    </div>
                </div>

                <!-- Download Options -->
                <div class="download-options">
                    <button class="download-option-btn both" onclick="showDownloadModal('both')">‚¨á Both Sides (ZIP)</button>
                    <button class="download-option-btn front" onclick="showDownloadModal('front')">‚¨á Front Only</button>
                    <button class="download-option-btn back" onclick="showDownloadModal('back')">‚¨á Back Only</button>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
           <button class="backbtn" onclick="goBack()">Back</button>

            <!-- Toolbar -->
            <div class="panel" id="toolbarPanel">
                <h3>Element Properties</h3>
                <div id="noSelection" class="empty-state">
                    Select an element to edit its properties
                </div>
                <div id="elementProperties" class="hidden"></div>
            </div>

            <!-- Layers -->
            <div class="panel">
                <h3>Layers (<span id="layerCount">0</span>)</h3>
                <div id="layersList"></div>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // Global variables for edit mode
        let isEditMode = false;
        let currentTemplateId = '';
        let currentAppId = '';
        let originalTemplateData = null;
        
        function goBack() {
            window.location.href = "template.html";
        }
        
        // Variables for modal functionality
        let currentDownloadMode = null;
        let userInfo = {
            fullName: '',
            phone: '',
            address: ''
        };

        // Export data
        let exportData = {
            accessType: '',
            templateName: '',
            service: '',
            exportType: 'both'
        };

        // API endpoints - CHANGE THESE TO YOUR ACTUAL ENDPOINTS
        const API_ENDPOINT = `http://192.168.20.103:80/skynetwork/admin/action/templates.php`;
        const TEMPLATE_DETAILS_API = 'http://192.168.20.103:80/skynetwork/admin/template-details.php';

        // Fixed Zoom functionality
        let zoomLevel = 1;
        const minZoom = 0.25;
        const maxZoom = 3;
        const zoomStep = 0.25;

        // Quality settings
        let downloadQuality = 4; // Default 4x scale

        // State Management
        let state = {
            front: {
                elements: [],
                background: '#ffffff',
                backgroundImage: null,
                width: 700,
                height: 450
            },
            back: {
                elements: [],
                background: '#ffffff',
                backgroundImage: null,
                width: 700,
                height: 450
            },
            activeSide: 'front',
            selectedElement: null,
            orientation: 'horizontal', // 'horizontal' or 'vertical'
            history: {
                front: [],
                back: []
            },
            historyIndex: {
                front: -1,
                back: -1
            }
        };

        let isDragging = false;
        let isResizing = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let resizeStartData = null;

        // FLAG TO PREVENT DOUBLE EXECUTION
        let isExporting = false;

        // Function to get URL parameters
        function getUrlParams() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const pairs = queryString.split('&');
            
            for (let i = 0; i < pairs.length; i++) {
                const pair = pairs[i].split('=');
                if (pair.length === 2) {
                    params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
                }
            }
            return params;
        }

        // Function to get app_id from localStorage
        function getAppId() {
            try {
                // Try to get app_id from localStorage
                const appId = localStorage.getItem('app_id');
                if (appId) {
                    return appId;
                }
                
                // If not found, check if user info exists and use phone number as app_id
                const savedUserInfo = localStorage.getItem('idCardUserInfo');
                if (savedUserInfo) {
                    const userInfo = JSON.parse(savedUserInfo);
                    if (userInfo.phone) {
                        // Save phone as app_id for future use
                        localStorage.setItem('app_id', userInfo.phone);
                        return userInfo.phone;
                    }
                }
                
                // If still not found, generate a random app_id
                const randomAppId = 'app_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('app_id', randomAppId);
                return randomAppId;
                
            } catch (e) {
                console.error('Error getting app_id:', e);
                // Generate a fallback app_id
                return 'app_' + Date.now();
            }
        }
document.addEventListener('DOMContentLoaded', async function () {
    await callTemplateAPI();
});

async function callTemplateAPI() {
    try {
        const payload = {
            app_id: "MQ--",
            tempid: "MQ--"
        };

        const response = await fetch(
            "http://192.168.20.103:80/skynetwork/admin/template-details.php",
            {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify(payload)
            }
        );

        if (!response.ok) {
            throw new Error("HTTP error " + response.status);
        }

        const data = await response.json();
        console.log("‚úÖ API DATA:", data);

        // üëâ call your loader here
        // loadProjectData(data);

    } catch (error) {
        console.error("‚ùå API ERROR:", error);
    }
}
        // Safe JSON parsing function
        function safeJsonParse(str) {
            try {
                return JSON.parse(str);
            } catch (e) {
                console.error('JSON parse error:', e);
                // Try to clean the JSON string
                const cleaned = str
                    .replace(/\\/g, '\\\\')
                    .replace(/\n/g, '\\n')
                    .replace(/\r/g, '\\r')
                    .replace(/\t/g, '\\t')
                    .replace(/"{/g, '{')
                    .replace(/}"/g, '}')
                    .replace(/\\"/g, '"');
                try {
                    return JSON.parse(cleaned);
                } catch (e2) {
                    // If still fails, try to extract JSON from string
                    const jsonMatch = str.match(/\{.*\}/s);
                    if (jsonMatch) {
                        try {
                            return JSON.parse(jsonMatch[0]);
                        } catch (e3) {
                            throw new Error('Failed to parse JSON: ' + e.message);
                        }
                    }
                    throw new Error('Invalid JSON format');
                }
            }
        }

        // Create placeholder image for missing images
        function createPlaceholderImage(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 150;
            canvas.height = 150;
            const ctx = canvas.getContext('2d');
            
            // Draw background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 150, 150);
            
            // Draw border
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(5, 5, 140, 140);
            
            // Draw text
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 75, 75);
            
            return canvas.toDataURL('image/png');
        }

        // IMPORT PROJECT FUNCTION
        function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                alert('Please select a JSON file');
                return;
            }
            
            showLoading();
            updateLoadingText('Loading project...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // Use safe JSON parsing
                    const importData = safeJsonParse(e.target.result);
                    
                    console.log('üîç Import Data Received:', importData);
                    
                    // Check if it's the new JSON format or old format
                    const isNewFormat = importData.elements && importData.canvasSize;
                    const isOldFormat = importData.projectData && importData.canvasData;
                    
                    if (!isNewFormat && !isOldFormat) {
                        hideLoading();
                        alert('‚ùå Invalid project file format');
                        return;
                    }
                    
                    if (!confirm('Importing will replace your current project. Continue?')) {
                        hideLoading();
                        return;
                    }
                    
                    if (isNewFormat) {
                        // ============ NEW JSON FORMAT HANDLING ============
                        console.log('‚úÖ Loading new JSON format');
                        
                        // Set canvas size from import data
                        state.front.width = importData.canvasSize?.width || 700;
                        state.front.height = importData.canvasSize?.height || 450;
                        state.back.width = importData.canvasSize?.width || 700;
                        state.back.height = importData.canvasSize?.height || 450;
                        
                        // Update input fields
                        document.getElementById('canvasWidth').value = state.front.width;
                        document.getElementById('canvasHeight').value = state.front.height;
                        
                        // Reset elements
                        state.front.elements = [];
                        state.back.elements = [];
                        state.selectedElement = null;
                        
                        // Process front elements
                        if (importData.elements?.front) {
                            importData.elements.front.forEach(element => {
                                const processedElement = processImportedElement(element);
                                if (processedElement) {
                                    state.front.elements.push(processedElement);
                                }
                            });
                            console.log(`‚úÖ Loaded ${state.front.elements.length} front elements`);
                        }
                        
                        // Process back elements
                        if (importData.elements?.back) {
                            importData.elements.back.forEach(element => {
                                const processedElement = processImportedElement(element);
                                if (processedElement) {
                                    state.back.elements.push(processedElement);
                                }
                            });
                            console.log(`‚úÖ Loaded ${state.back.elements.length} back elements`);
                        }
                        
                        // Load canvas background
                        if (importData.canvasBackground) {
                            state.front.background = importData.canvasBackground;
                            state.back.background = importData.canvasBackground;
                            document.getElementById('bgColorInput').value = importData.canvasBackground;
                        }
                        
                        // Hide back side button if no back elements
                        if (!importData.elements?.back || importData.elements.back.length === 0) {
                            document.getElementById('backSideBtn').style.display = 'none';
                        } else {
                            document.getElementById('backSideBtn').style.display = 'block';
                        }
                        
                        // Load export data if available
                        if (importData.exportData) {
                            exportData = importData.exportData;
                            // Update modal fields
                            document.getElementById('templateNameInput').value = exportData.templateName || '';
                            document.getElementById('serviceSelect').value = exportData.service || '';
                            
                            // Set access type
                            if (exportData.accessType) {
                                const accessTypeRadio = document.querySelector(`input[name="accessType"][value="${exportData.accessType}"]`);
                                if (accessTypeRadio) {
                                    accessTypeRadio.checked = true;
                                    accessTypeRadio.parentElement.classList.add('selected');
                                }
                            }
                            
                            // Set export type
                            if (exportData.exportType) {
                                const exportTypeRadio = document.querySelector(`input[name="exportType"][value="${exportData.exportType}"]`);
                                if (exportTypeRadio) {
                                    exportTypeRadio.checked = true;
                                    exportTypeRadio.parentElement.classList.add('selected');
                                }
                            }
                        }
                        
                        // Update UI
                        updateUI();
                        
                        hideLoading();
                        alert(`‚úÖ Project imported successfully!\n\nFront: ${state.front.elements.length} elements\nBack: ${state.back.elements.length} elements\nSize: ${state.front.width} x ${state.front.height}px`);
                        
                    } else {
                        // ============ OLD FORMAT HANDLING ============
                        console.log('Loading old format');
                        
                        if (importData.canvasData) {
                            state.front = importData.canvasData.front || state.front;
                            state.back = importData.canvasData.back || state.back;
                            state.activeSide = importData.canvasData.activeSide || 'front';
                            
                            // Update input fields
                            document.getElementById('canvasWidth').value = state.front.width;
                            document.getElementById('canvasHeight').value = state.front.height;
                            
                            if (state.front.background) {
                                document.getElementById('bgColorInput').value = state.front.background;
                            }
                        }
                        
                        // Reset history and update UI
                        state.history.front = [];
                        state.history.back = [];
                        state.historyIndex.front = -1;
                        state.historyIndex.back = -1;
                        
                        saveToHistory();
                        switchSide(state.activeSide);
                        updateUI();
                        
                        hideLoading();
                        alert('‚úÖ Project loaded successfully!');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Import error:', error);
                    hideLoading();
                    alert('‚ùå Error importing project file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function processImportedElement(element) {
            // Handle both old and new element formats
            if (!element || !element.type) return null;
            
            console.log('Processing element:', element);
            
            const processedElement = {
                id: element.id || Date.now().toString(),
                type: element.type,
                content: element.content || '',
                x: element.x || 50,
                y: element.y || 50,
                width: element.width || 150,
                height: element.height || 150,
                rotation: element.rotation || 0,
                opacity: element.opacity || 1,
                borderRadius: element.borderRadius || 0,
                borderWidth: element.borderWidth || 0,
                borderColor: element.borderColor || '#000000'
            };
            
            if (element.type === 'text') {
                // Map text properties from new format to existing format
                processedElement.fontSize = element.fontSize || 24;
                processedElement.color = element.color || '#333333';
                processedElement.fontFamily = element.fontFamily || "'Inter', sans-serif";
                processedElement.fontWeight = element.fontWeight || 'normal';
                processedElement.fontStyle = element.fontStyle || 'normal';
                processedElement.textDecoration = element.textDecoration || 'none';
                processedElement.textAlign = element.textAlign || 'left';
                processedElement.textTransform = element.textTransform || 'none';
                processedElement.letterSpacing = element.letterSpacing || 'normal';
                processedElement.lineHeight = element.lineHeight || 'normal';
                processedElement.textBackgroundColor = element.textBackgroundColor || 'transparent';
                processedElement.textBorderWidth = element.textBorderWidth || 0;
                processedElement.textBorderColor = element.textBorderColor || '#000000';
                processedElement.textBorderRadius = element.textBorderRadius || 0;
                processedElement.textPadding = element.textPadding || 5;
            } else if (element.type === 'image') {
                // For images, ensure content is valid
                if (processedElement.content) {
                    if (!processedElement.content.startsWith('data:image')) {
                        // If it's base64 without data URL prefix
                        if (processedElement.content.includes('base64')) {
                            processedElement.content = 'data:image/png;base64,' + processedElement.content.replace('data:image/png;base64,', '');
                        } else {
                            // Check if it's a URL or base64 string
                            if (processedElement.content.length > 1000 || processedElement.content.includes('/9j/') || processedElement.content.includes('iVBORw')) {
                                // Likely base64 image data
                                processedElement.content = 'data:image/png;base64,' + processedElement.content;
                            } else {
                                processedElement.content = createPlaceholderImage('Imported Image');
                            }
                        }
                    }
                } else {
                    processedElement.content = createPlaceholderImage('Missing Image');
                }
            }
            
            return processedElement;
        }

        // LOAD TEMPLATE FUNCTION - Called when page loads with template parameters
        async function loadTemplateForEditing() {
            // Get template parameters from URL
            const params = getUrlParams();
            const templateId = params.tempid || params.template_id || params.id;
            const appId = params.appid || params.app_id || getAppId();
            
            console.log('üìã URL Parameters:', params);
            console.log('üîç Looking for template with:', { templateId, appId });
            
            if (!templateId) {
                console.log('No template ID found in URL');
                return;
            }
            
            console.log('üîÑ Loading template for editing...');
            
            try {
                showLoading();
                updateLoadingText('Loading template data from API...');
                
                // Prepare request data
                const requestData = {
                    app_id: appId,
                    tempid: templateId
                };
                
                console.log('üì§ Sending request to template-details.php:', requestData);
                
                // Fetch template data from template-details.php
                const response = await fetch(TEMPLATE_DETAILS_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('üì• Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const responseText = await response.text();
                console.log('üì• Raw response:', responseText);
                
                let data;
                try {
                    data = safeJsonParse(responseText);
                } catch (parseError) {
                    console.error('Failed to parse response as JSON:', parseError);
                    throw new Error('Invalid JSON response from server');
                }
                
                console.log('‚úÖ Parsed API Response:', data);
                
                // Handle different response formats
                let templateData = null;
                
                if (data.success && data.data) {
                    // Format 1: {success: true, data: {...}}
                    templateData = data.data;
                } else if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    // Format 2: {data: [{...}]}
                    templateData = data.data[0];
                } else if (data.template) {
                    // Format 3: {template: {...}}
                    templateData = data.template;
                } else if (Array.isArray(data) && data.length > 0) {
                    // Format 4: [{...}]
                    templateData = data.find(t => t.id === templateId || t.tempid === templateId) || data[0];
                } else if (typeof data === 'object') {
                    // Format 5: direct object
                    templateData = data;
                }
                
                console.log('üéØ Extracted template data:', templateData);
                
                if (!templateData) {
                    throw new Error('No template data found in response');
                }
                
                // Parse JSON data from template
                let jsonData = {};
                if (templateData.json_data) {
                    try {
                        if (typeof templateData.json_data === 'string') {
                            jsonData = safeJsonParse(templateData.json_data);
                        } else {
                            jsonData = templateData.json_data;
                        }
                        console.log('üìä Parsed json_data:', jsonData);
                    } catch (parseError) {
                        console.error('Error parsing json_data:', parseError);
                        // Try to extract JSON from the string
                        try {
                            const jsonMatch = templateData.json_data.match(/\{.*\}/s);
                            if (jsonMatch) {
                                jsonData = safeJsonParse(jsonMatch[0]);
                            } else {
                                throw new Error('No JSON found in json_data');
                            }
                        } catch (e) {
                            console.error('Failed to extract JSON:', e);
                        }
                    }
                } else if (templateData.elements) {
                    // Direct elements data
                    jsonData = templateData;
                } else {
                    // Try to parse the entire template data as JSON structure
                    jsonData = templateData;
                }
                
                // Store original data for edit mode
                originalTemplateData = {
                    templateId: templateId,
                    appId: appId,
                    templateName: templateData.name || templateData.template_name || 'Untitled',
                    service: templateData.service || 'ID Card',
                    access: templateData.access || 'All',
                    jsonData: jsonData,
                    date: templateData.date || new Date().toLocaleString(),
                    rawData: templateData
                };
                
                // Set edit mode
                isEditMode = true;
                currentTemplateId = templateId;
                currentAppId = appId;
                
                // Update UI for edit mode
                document.getElementById('editModeBanner').classList.add('show');
                document.getElementById('templateIdDisplay').textContent = templateId;
                document.getElementById('appTitle').textContent = 'ID Card Editor - Edit Mode';
                document.getElementById('exportElementsMainBtn').style.display = 'none';
                document.getElementById('updateTemplateBtn').style.display = 'block';
                
                // Clear current elements
                state.front.elements = [];
                state.back.elements = [];
                
                // Load elements into state
                if (jsonData.elements) {
                    // Check if elements is an object with front/back properties
                    if (jsonData.elements.front && Array.isArray(jsonData.elements.front)) {
                        state.front.elements = jsonData.elements.front.map(element => {
                            return processImportedElement(element);
                        }).filter(Boolean);
                        console.log(`‚úÖ Loaded ${state.front.elements.length} front elements`);
                    } else if (Array.isArray(jsonData.elements)) {
                        // If elements is a simple array, put all in front
                        state.front.elements = jsonData.elements.map(element => {
                            return processImportedElement(element);
                        }).filter(Boolean);
                        console.log(`‚úÖ Loaded ${state.front.elements.length} elements to front`);
                    }
                    
                    if (jsonData.elements.back && Array.isArray(jsonData.elements.back)) {
                        state.back.elements = jsonData.elements.back.map(element => {
                            return processImportedElement(element);
                        }).filter(Boolean);
                        console.log(`‚úÖ Loaded ${state.back.elements.length} back elements`);
                    }
                } else if (jsonData.front || jsonData.back) {
                    // Alternative structure
                    if (jsonData.front && Array.isArray(jsonData.front)) {
                        state.front.elements = jsonData.front.map(element => {
                            return processImportedElement(element);
                        }).filter(Boolean);
                    }
                    if (jsonData.back && Array.isArray(jsonData.back)) {
                        state.back.elements = jsonData.back.map(element => {
                            return processImportedElement(element);
                        }).filter(Boolean);
                    }
                } else if (Array.isArray(jsonData)) {
                    // If jsonData itself is an array of elements
                    state.front.elements = jsonData.map(element => {
                        return processImportedElement(element);
                    }).filter(Boolean);
                }
                
                // Load canvas size
                if (jsonData.canvasSize) {
                    state.front.width = jsonData.canvasSize.width || 700;
                    state.front.height = jsonData.canvasSize.height || 450;
                    state.back.width = jsonData.canvasSize.width || 700;
                    state.back.height = jsonData.canvasSize.height || 450;
                    
                    // Update input fields
                    document.getElementById('canvasWidth').value = state.front.width;
                    document.getElementById('canvasHeight').value = state.front.height;
                    console.log(`üìè Canvas size: ${state.front.width} x ${state.front.height}`);
                }
                
                // Load export data from template
                if (jsonData.exportData) {
                    exportData = jsonData.exportData;
                } else {
                    exportData = {
                        accessType: (templateData.access || 'All').toLowerCase() === 'all' ? 'all' : 'dealer',
                        templateName: templateData.name || templateData.template_name || 'Untitled',
                        service: templateData.service || 'ID Card',
                        exportType: 'both'
                    };
                }
                
                console.log('üìã Export data:', exportData);
                
                // Update modal fields
                document.getElementById('templateNameInput').value = exportData.templateName;
                document.getElementById('serviceSelect').value = exportData.service;
                
                // Set access type
                const accessType = exportData.accessType;
                const accessTypeRadio = document.querySelector(`input[name="accessType"][value="${accessType}"]`);
                if (accessTypeRadio) {
                    accessTypeRadio.checked = true;
                    accessTypeRadio.parentElement.classList.add('selected');
                }
                
                // Set export type
                const exportType = exportData.exportType || 'both';
                const exportTypeRadio = document.querySelector(`input[name="exportType"][value="${exportType}"]`);
                if (exportTypeRadio) {
                    exportTypeRadio.checked = true;
                    exportTypeRadio.parentElement.classList.add('selected');
                }
                
                // Save to history
                saveToHistory();
                
                // Update UI
                updateUI();
                updateEstimatedSize();
                
                hideLoading();
                
                // Show success message
                setTimeout(() => {
                    alert(`‚úÖ Template "${exportData.templateName}" loaded successfully!\n\nüìÖ Date: ${originalTemplateData.date}\nüé® Front Elements: ${state.front.elements.length}\nüé® Back Elements: ${state.back.elements.length}\nüìè Size: ${state.front.width} x ${state.front.height}px`);
                }, 500);
                
            } catch (error) {
                console.error('‚ùå Error loading template:', error);
                hideLoading();
                alert(`‚ùå Error loading template: ${error.message}\n\nPlease check if the template exists and try again.`);
            }
        }

        // Initialize function
        async function init() {
            console.log('üöÄ Initializing ID Card Editor...');
            
            // Add input event listeners for real-time validation
            document.getElementById('fullNameInput').addEventListener('input', validateForm);
            document.getElementById('phoneInput').addEventListener('input', validateForm);
            document.getElementById('addressInput').addEventListener('input', validateForm);
            
            // Check if we have template parameters in URL (for edit mode)
            const params = getUrlParams();
            const hasTemplateParams = params.tempid || params.template_id || params.id;
            
            console.log('üìã URL Parameters:', params);
            console.log('üîç Has template params:', hasTemplateParams);
            
            if (hasTemplateParams) {
                // Automatically load template for editing
                console.log('üîÑ Loading template for editing...');
                await loadTemplateForEditing();
            } else {
                // Normal initialization for new template
                console.log('üÜï Starting new template...');
                saveToHistory();
                updateUI();
                updateZoomDisplay();
                updateQualityValue();
            }
            
            // Initialize export modal event listeners
            initExportModal();
            
            // Allow pressing Enter to save in modal
            document.getElementById('userInfoModal').addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && !document.getElementById('saveBtn').disabled) {
                    saveUserInfo();
                }
            });
            
            // Get app_id from localStorage on init
            const appId = getAppId();
            console.log('üÜî App ID on init:', appId);
            
            // Update size estimate when canvas size changes
            document.getElementById('canvasWidth').addEventListener('input', updateEstimatedSize);
            document.getElementById('canvasHeight').addEventListener('input', updateEstimatedSize);
            
            // Click outside elements to deselect
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('canvas')) {
                    state.selectedElement = null;
                    updateUI();
                }
            });
            
            // Prevent form submission
            document.querySelectorAll('form').forEach(form => {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                });
            });
            
            console.log('‚úÖ Initialization complete');
        }

        // NEW: Export Elements Modal functions
        function showExportElementsModal() {
            // Reset modal title for normal export
            if (!isEditMode) {
                document.getElementById('exportModalTitle').textContent = 'Export Elements';
                document.getElementById('exportModalSubtitle').textContent = 'Configure export settings and send to API';
                document.getElementById('exportElementsBtn').textContent = 'Export & Download';
                document.getElementById('exportRequirementsTitle').textContent = 'Export Information:';
            } else {
                document.getElementById('exportModalTitle').textContent = 'Update Template';
                document.getElementById('exportModalSubtitle').textContent = 'Update template and save changes to API';
                document.getElementById('exportElementsBtn').textContent = 'Update Template';
                document.getElementById('exportRequirementsTitle').textContent = 'Update Information:';
            }
            
            loadSavedExportData();
            document.getElementById('exportElementsModal').classList.add('active');
            validateExportForm();
        }

        function closeExportElementsModal() {
            document.getElementById('exportElementsModal').classList.remove('active');
            clearExportErrors();
            // Reset export flag when modal closes
            isExporting = false;
            const exportBtn = document.getElementById('exportElementsBtn');
            exportBtn.disabled = false;
            exportBtn.textContent = isEditMode ? 'Update Template' : 'Export & Download';
        }

        function selectRadio(radioElement) {
            // Remove selected class from all radio options
            const allRadios = document.querySelectorAll('#accessTypeGroup .radio-option');
            allRadios.forEach(radio => {
                radio.classList.remove('selected');
            });
            
            // Add selected class to clicked option
            radioElement.classList.add('selected');
            const radioInput = radioElement.querySelector('input[type="radio"]');
            radioInput.checked = true;
            
            validateExportForm();
        }

        function selectExportType(radioElement) {
            // Remove selected class from all export type options
            const allExportTypes = document.querySelectorAll('input[name="exportType"]').forEach(input => {
                input.parentElement.classList.remove('selected');
            });
            
            // Add selected class to clicked option
            radioElement.classList.add('selected');
            
            validateExportForm();
        }

        function loadSavedExportData() {
            const savedData = localStorage.getItem('idCardExportData');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    
                    // Set template name
                    if (parsedData.templateName) {
                        document.getElementById('templateNameInput').value = parsedData.templateName;
                    }
                    
                    // Set service
                    if (parsedData.service) {
                        document.getElementById('serviceSelect').value = parsedData.service;
                    }
                    
                    // Set access type
                    if (parsedData.accessType) {
                        const radios = document.querySelectorAll('input[name="accessType"]');
                        radios.forEach(radio => {
                            if (radio.value === parsedData.accessType) {
                                radio.checked = true;
                                radio.parentElement.classList.add('selected');
                            }
                        });
                    }
                    
                    // Set export type
                    if (parsedData.exportType) {
                        const exportRadios = document.querySelectorAll('input[name="exportType"]');
                        exportRadios.forEach(radio => {
                            if (radio.value === parsedData.exportType) {
                                radio.checked = true;
                                radio.parentElement.classList.add('selected');
                            }
                        });
                    }
                    
                    validateExportForm();
                } catch (e) {
                    console.error('Error loading saved export data:', e);
                }
            }
        }

        function saveExportDataToLocalStorage() {
            try {
                localStorage.setItem('idCardExportData', JSON.stringify(exportData));
                console.log('Export data saved to localStorage');
            } catch (e) {
                console.error('Error saving export data:', e);
            }
        }

        // Validation for export form
        function validateExportForm() {
            const templateName = document.getElementById('templateNameInput').value.trim();
            const service = document.getElementById('serviceSelect').value;
            const accessType = document.querySelector('input[name="accessType"]:checked');
            const exportType = document.querySelector('input[name="exportType"]:checked');
            
            let isValid = true;

            // Validate template name
            const templateNameError = document.getElementById('templateNameError');
            const templateNameInput = document.getElementById('templateNameInput');
            if (!templateName) {
                templateNameError.classList.add('show');
                templateNameInput.classList.add('error');
                isValid = false;
            } else {
                templateNameError.classList.remove('show');
                templateNameInput.classList.remove('error');
            }

            // Validate service
            const serviceError = document.getElementById('serviceError');
            const serviceSelect = document.getElementById('serviceSelect');
            if (!service) {
                serviceError.classList.add('show');
                serviceSelect.classList.add('error');
                isValid = false;
            } else {
                serviceError.classList.remove('show');
                serviceSelect.classList.remove('error');
            }

            // Validate access type
            const accessTypeError = document.getElementById('accessTypeError');
            if (!accessType) {
                accessTypeError.classList.add('show');
                isValid = false;
            } else {
                accessTypeError.classList.remove('show');
            }

            // Enable/disable export button
            const exportBtn = document.getElementById('exportElementsBtn');
            exportBtn.disabled = !isValid || isExporting;

            return isValid;
        }

        function clearExportErrors() {
            document.querySelectorAll('#exportElementsModal .error-message').forEach(el => {
                el.classList.remove('show');
            });
            document.querySelectorAll('#exportElementsModal .form-input').forEach(el => {
                el.classList.remove('error');
            });
        }

        // Show update template modal (modified export modal for edit mode)
        function showUpdateTemplateModal() {
            showExportElementsModal();
        }

        // FIXED: Handle export click with double execution prevention
        function handleExportClick(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Prevent double execution
            if (isExporting) {
                console.log('Already exporting, please wait...');
                return;
            }
            
            // Validate form
            if (!validateExportForm()) {
                return;
            }
            
            if (isEditMode) {
                updateTemplateToAPI();
            } else {
                exportElementsToAPI();
            }
        }

        // NEW FUNCTION: Update template to API (for edit mode)
        async function updateTemplateToAPI() {
            // Prevent double execution
            if (isExporting) {
                console.log('Already updating, please wait...');
                return;
            }
            
            if (!validateExportForm()) {
                return;
            }

            // Set flag to prevent double execution
            isExporting = true;
            const exportBtn = document.getElementById('exportElementsBtn');
            exportBtn.disabled = true;
            exportBtn.textContent = 'Updating...';

            // Get export data from form
            const accessType = document.querySelector('input[name="accessType"]:checked');
            const exportType = document.querySelector('input[name="exportType"]:checked');
            
            exportData = {
                accessType: accessType ? accessType.value : '',
                templateName: document.getElementById('templateNameInput').value.trim(),
                service: document.getElementById('serviceSelect').value,
                exportType: exportType ? exportType.value : 'both'
            };

            // Save export data to localStorage
            saveExportDataToLocalStorage();

            // Show loading
            showLoading();
            updateLoadingText('Preparing update data...');

            try {
                // Prepare elements data based on export type
                let elementsData = {};
                
                if (exportData.exportType === 'both') {
                    elementsData = {
                        front: state.front.elements,
                        back: state.back.elements
                    };
                } else if (exportData.exportType === 'front') {
                    elementsData = {
                        front: state.front.elements
                    };
                } else if (exportData.exportType === 'back') {
                    elementsData = {
                        back: state.back.elements
                    };
                }

                // Prepare the final payload in backend format
                const finalPayload = {
                    app_id: currentAppId,
                    tempid: currentTemplateId,
                    action: "edit",
                    exportData: exportData,
                    elements: elementsData,
                    canvasSize: {
                        width: state.front.width,
                        height: state.front.height
                    }
                };

                console.log('Update Payload for Backend:', finalPayload);

                // Send to API
                updateLoadingText('Sending update to backend...');
                
                let success = false;
                let result = null;
                let apiError = null;

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000);

                    console.log('Sending update to backend API...');

                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(finalPayload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`API request failed with status: ${response.status}`);
                    }

                    result = await response.json();
                    console.log('Backend API Response:', result);

                    success = true;

                } catch (error) {
                    console.error('Backend API Error:', error);
                    apiError = error;
                }

                // Always download JSON file locally, regardless of API success
                updateLoadingText('Downloading updated JSON file...');
                
                // Prepare complete payload for local download
                const localPayload = {
                    ...finalPayload,
                    version: "1.0.0",
                    updateDate: new Date().toISOString(),
                    sentToAPI: success,
                    timestamp: new Date().toISOString(),
                    originalTemplateData: originalTemplateData
                };

                // Add API response if available
                if (result) {
                    localPayload.apiResponse = result;
                }

                // Download JSON file
                downloadJSONFile(localPayload);
                
                // Close modal
                closeExportElementsModal();
                
                if (success) {
                    // Show success message
                    alert(`‚úÖ Template "${exportData.templateName}" updated successfully!\n\n‚úÖ Data sent to API\n‚úÖ Updated JSON file downloaded locally`);
                } else {
                    // Show warning message
                    alert(`‚ö†Ô∏è Template "${exportData.templateName}" updated locally.\n\nAPI Error: ${apiError?.message || 'Connection failed'}\n\nUpdated JSON file has been downloaded locally.`);
                }
                
            } catch (error) {
                console.error('Update error:', error);
                
                // Prepare fallback local payload
                updateLoadingText('Error occurred, downloading locally...');
                
                // Get elements data for local download
                let elementsData = {};
                if (exportData.exportType === 'both') {
                    elementsData = {
                        front: state.front.elements,
                        back: state.back.elements
                    };
                } else if (exportData.exportType === 'front') {
                    elementsData = {
                        front: state.front.elements
                    };
                } else if (exportData.exportType === 'back') {
                    elementsData = {
                        back: state.back.elements
                    };
                }
                
                // Prepare local payload
                const localPayload = {
                    app_id: currentAppId,
                    tempid: currentTemplateId,
                    action: "edit",
                    exportData: exportData,
                    elements: elementsData,
                    canvasSize: {
                        width: state.front.width,
                        height: state.front.height
                    },
                    version: "1.0.0",
                    updateDate: new Date().toISOString(),
                    sentToAPI: false,
                    apiError: error.message,
                    timestamp: new Date().toISOString(),
                    originalTemplateData: originalTemplateData
                };

                downloadJSONFile(localPayload);
                
                closeExportElementsModal();
                alert(`‚ö†Ô∏è Template "${exportData.templateName}" updated locally.\n\nError: ${error.message}\n\nUpdated JSON file has been downloaded locally.`);
            } finally {
                hideLoading();
                // Reset export flag
                isExporting = false;
            }
        }

        // Main function to export elements to API and download JSON - FIXED
        async function exportElementsToAPI() {
            // Prevent double execution
            if (isExporting) {
                console.log('Already exporting, please wait...');
                return;
            }
            
            if (!validateExportForm()) {
                return;
            }

            // Set flag to prevent double execution
            isExporting = true;
            const exportBtn = document.getElementById('exportElementsBtn');
            exportBtn.disabled = true;
            exportBtn.textContent = 'Exporting...';

            // Get export data from form
            const accessType = document.querySelector('input[name="accessType"]:checked');
            const exportType = document.querySelector('input[name="exportType"]:checked');
            
            exportData = {
                accessType: accessType ? accessType.value : '',
                templateName: document.getElementById('templateNameInput').value.trim(),
                service: document.getElementById('serviceSelect').value,
                exportType: exportType ? exportType.value : 'both'
            };

            // Save export data to localStorage
            saveExportDataToLocalStorage();

            // Get app_id from localStorage
            const app_id = getAppId();
            console.log('Using App ID from localStorage:', app_id);

            // Show loading
            showLoading();
            updateLoadingText('Preparing export data...');

            try {
                // Prepare elements data based on export type
                let elementsData = {};
                
                if (exportData.exportType === 'both') {
                    elementsData = {
                        front: state.front.elements,
                        back: state.back.elements
                    };
                } else if (exportData.exportType === 'front') {
                    elementsData = {
                        front: state.front.elements
                    };
                } else if (exportData.exportType === 'back') {
                    elementsData = {
                        back: state.back.elements
                    };
                }

                // Prepare the final payload in backend format
                const finalPayload = {
                    app_id: app_id,
                    action: "insert",
                    exportData: exportData,
                    elements: elementsData,
                    canvasSize: {
                        width: state.front.width,
                        height: state.front.height
                    }
                };

                console.log('Final Payload for Backend:', finalPayload);

                // Send to API
                updateLoadingText('Sending data to API...');
                
                let success = false;
                let result = null;
                let apiError = null;

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000);

                    console.log('Sending to backend API...');

                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(finalPayload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`API request failed with status: ${response.status}`);
                    }

                    result = await response.json();
                    console.log('API Response:', result);

                    success = true;

                } catch (error) {
                    console.error('API Error:', error);
                    apiError = error;
                }

                // Always download JSON file locally, regardless of API success
                updateLoadingText('Downloading JSON file...');
                
                // Prepare complete payload for local download
                const localPayload = {
                    ...finalPayload,
                    version: "1.0.0",
                    exportDate: new Date().toISOString(),
                    sentToAPI: success,
                    timestamp: new Date().toISOString()
                };

                // Add API response if available
                if (result) {
                    localPayload.apiResponse = result;
                }

                // Download JSON file
                downloadJSONFile(localPayload);
                
                // Close modal
                closeExportElementsModal();
                
                if (success) {
                    // Show success message
                    alert(`‚úÖ Template "${exportData.templateName}" exported successfully!\n\n‚úÖ Data sent to API\n‚úÖ JSON file downloaded locally`);
                } else {
                    // Show warning message
                    alert(`‚ö†Ô∏è Template "${exportData.templateName}" saved locally.\n\nAPI Error: ${apiError?.message || 'Connection failed'}\n\nJSON file has been downloaded locally.`);
                }
                
            } catch (error) {
                console.error('Export error:', error);
                
                // Prepare fallback local payload
                updateLoadingText('Error occurred, downloading locally...');
                
                // Get elements data for local download
                let elementsData = {};
                if (exportData.exportType === 'both') {
                    elementsData = {
                        front: state.front.elements,
                        back: state.back.elements
                    };
                } else if (exportData.exportType === 'front') {
                    elementsData = {
                        front: state.front.elements
                    };
                } else if (exportData.exportType === 'back') {
                    elementsData = {
                        back: state.back.elements
                    };
                }
                
                // Prepare local payload
                const localPayload = {
                    app_id: app_id || 'local_' + Date.now(),
                    action: "insert",
                    exportData: exportData,
                    elements: elementsData,
                    canvasSize: {
                        width: state.front.width,
                        height: state.front.height
                    },
                    version: "1.0.0",
                    exportDate: new Date().toISOString(),
                    sentToAPI: false,
                    apiError: error.message,
                    timestamp: new Date().toISOString()
                };

                downloadJSONFile(localPayload);
                
                closeExportElementsModal();
                alert(`‚ö†Ô∏è Template "${exportData.templateName}" saved locally.\n\nError: ${error.message}\n\nJSON file has been downloaded locally.`);
            } finally {
                hideLoading();
                // Reset export flag
                isExporting = false;
            }
        }

        // Enhanced downloadJSONFile function
        function downloadJSONFile(data) {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const actionType = data.action === 'edit' ? 'updated' : 'exported';
            link.download = `template-${exportData.templateName || 'template'}-${actionType}-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log('JSON file downloaded with app_id:', data.app_id);
        }

        // Update UI function
        function updateUI() {
            renderCanvas();
            renderLayers();
            renderToolbar();
            updateUndoRedoButtons();
            updateEstimatedSize();
        }

        // Update zoom display
        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            document.getElementById('canvasWrapper').style.transform = `scale(${zoomLevel})`;

            // Disable buttons at limits
            document.getElementById('zoomOutBtn').disabled = zoomLevel <= minZoom;
            document.getElementById('zoomInBtn').disabled = zoomLevel >= maxZoom;
        }

        // Update quality value display
        function updateQualityValue() {
            downloadQuality = parseInt(document.getElementById('qualitySlider').value);
            document.getElementById('qualityValue').textContent = downloadQuality + 'x';
            updateEstimatedSize();
        }

        // Update estimated file size
        function updateEstimatedSize() {
            const side = state.activeSide;
            const canvasState = state[side];
            const baseSize = (canvasState.width * canvasState.height) / 1000000; // MP
            const scaledSize = baseSize * (downloadQuality * downloadQuality);
            const estimatedSizeMB = Math.min(scaledSize * 0.5, 1024); // Conservative estimate
            const estimatedSizeGB = estimatedSizeMB / 1024;

            let sizeText;
            if (estimatedSizeGB >= 1) {
                sizeText = `Estimated: ~${estimatedSizeGB.toFixed(1)} GB`;
            } else {
                sizeText = `Estimated: ~${Math.round(estimatedSizeMB)} MB`;
            }

            document.getElementById('estimatedSize').textContent = sizeText;

            // Show warning for large sizes
            const warning = document.getElementById('sizeWarning');
            if (scaledSize > 100) {
                warning.style.display = 'block';
            } else {
                warning.style.display = 'none';
            }
        }

        // Zoom in
        function zoomIn() {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
                updateZoomDisplay();
            }
        }

        // Zoom out
        function zoomOut() {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
                updateZoomDisplay();
            }
        }

        // Reset zoom
        function resetZoom() {
            zoomLevel = 1;
            updateZoomDisplay();
        }

        // Canvas border radius
        function updateRadius(value) {
            document.querySelectorAll('.canvas').forEach(canvas => {
                canvas.style.borderRadius = value + 'px';
            });
            document.getElementById('radiusValue').innerText = value;
        }

        // Orientation Management
        function setOrientation(orientation) {
            state.orientation = orientation;

            // Update UI buttons
            document.getElementById('horizontalBtn').classList.toggle('active', orientation === 'horizontal');
            document.getElementById('verticalBtn').classList.toggle('active', orientation === 'vertical');

            // Update size based on orientation
            if (orientation === 'vertical') {
                setCanvasSize(450, 700);
            } else {
                setCanvasSize(700, 450);
            }
        }

        // Unified canvas size function
        function setCanvasSize(width, height) {
            // Update both sides
            ['front', 'back'].forEach(side => {
                state[side].width = width;
                state[side].height = height;
            });

            // Update manual input fields
            document.getElementById('canvasWidth').value = width;
            document.getElementById('canvasHeight').value = height;

            saveToHistory();
            updateUI();
            updateEstimatedSize();
        }

        // Apply manual size
        function applyCanvasSize() {
            let w = parseInt(document.getElementById("canvasWidth").value);
            let h = parseInt(document.getElementById("canvasHeight").value);

            if (w <= 0 || h <= 0 || isNaN(w) || isNaN(h)) {
                alert("Please enter valid width and height (greater than 0)");
                return;
            }

            if (w > 10000 || h > 10000) {
                if (!confirm("Sizes above 10000px may cause performance issues. Continue?")) {
                    return;
                }
            }

            setCanvasSize(w, h);
        }

        // History Management
        function saveToHistory() {
            const side = state.activeSide;
            const currentState = JSON.parse(JSON.stringify(state[side]));

            state.history[side] = state.history[side].slice(0, state.historyIndex[side] + 1);
            state.history[side].push(currentState);
            state.historyIndex[side] = state.history[side].length - 1;

            updateUndoRedoButtons();
        }

        function undo() {
            const side = state.activeSide;
            if (state.historyIndex[side] > 0) {
                state.historyIndex[side]--;
                state[side] = JSON.parse(JSON.stringify(state.history[side][state.historyIndex[side]]));
                state.selectedElement = null;
                updateUI();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            const side = state.activeSide;
            if (state.historyIndex[side] < state.history[side].length - 1) {
                state.historyIndex[side]++;
                state[side] = JSON.parse(JSON.stringify(state.history[side][state.historyIndex[side]]));
                state.selectedElement = null;
                updateUI();
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            const side = state.activeSide;
            document.getElementById('undoBtn').disabled = state.historyIndex[side] <= 0;
            document.getElementById('redoBtn').disabled = state.historyIndex[side] >= state.history[side].length - 1;
        }

        // Side Management
        function switchSide(side) {
            state.activeSide = side;
            state.selectedElement = null;

            // Update UI
            document.getElementById('frontSideBtn').classList.toggle('active', side === 'front');
            document.getElementById('backSideBtn').classList.toggle('active', side === 'back');
            document.getElementById('frontCanvas').classList.toggle('hidden', side !== 'front');
            document.getElementById('backCanvas').classList.toggle('hidden', side !== 'back');
            document.getElementById('sideIndicator').textContent = side === 'front' ? 'üìÑ Front Side' : 'üìÑ Back Side';

            updateUI();
            updateUndoRedoButtons();
        }

        // Add Elements
        function addText(text) {
            if (!text) return;
            const element = {
                id: Date.now().toString(),
                type: 'text',
                content: text,
                x: 50,
                y: 50,
                fontSize: 24,
                color: '#333333',
                fontWeight: 'normal',
                fontStyle: 'normal',
                textTransform: 'none',
                textAlign: 'left',
                textShadow: '',
                opacity: 1,
                width: 250,
                rotation: 0,
                fontFamily: 'Inter, sans-serif',
                letterSpacing: 'normal',
                lineHeight: 'normal',
                textDecoration: 'none',
                textBackgroundColor: 'transparent',
                textBorderWidth: 0,
                textBorderColor: '#000000',
                textBorderRadius: 0,
                textPadding: 5
            };
            state[state.activeSide].elements.push(element);
            state.selectedElement = element.id;
            saveToHistory();
            updateUI();
        }

        function addCustomText() {
            const input = document.getElementById('textInput');
            if (input.value.trim()) {
                addText(input.value);
                input.value = '';
            }
        }

        function addImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const element = {
                    id: Date.now().toString(),
                    type: 'image',
                    content: e.target.result,
                    x: 50,
                    y: 50,
                    width: 140,
                    height: 160,
                    borderRadius: 0,
                    borderWidth: 0,
                    borderColor: '#000000',
                    filter: 'none',
                    boxShadow: false,
                    opacity: 1,
                    rotation: 0
                };
                state[state.activeSide].elements.push(element);
                state.selectedElement = element.id;
                saveToHistory();
                updateUI();
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function addQRCode() {
            const input = document.getElementById('qrInput');
            if (!input.value.trim()) return;

            QRCode.toDataURL(input.value, { width: 150 }, (err, url) => {
                if (err) {
                    console.error("QR Generation Error:", err);
                    alert("Error generating QR code");
                    return;
                }

                const element = {
                    id: Date.now().toString(),
                    type: 'image',
                    content: url,
                    x: 50,
                    y: 50,
                    width: 150,
                    height: 150,
                    borderRadius: 0,
                    borderWidth: 0,
                    borderColor: '#000000',
                    filter: 'none',
                    boxShadow: false,
                    opacity: 1,
                    rotation: 0
                };

                state[state.activeSide].elements.push(element);
                state.selectedElement = element.id;
                saveToHistory();
                updateUI();
            });

            input.value = '';
        }

        function addBarcode() {
            const input = document.getElementById('barcodeInput');
            if (!input.value.trim()) return;

            const canvas = document.createElement('canvas');

            try {
                JsBarcode(canvas, input.value, {
                    format: "CODE128",
                    width: 2,
                    height: 80,
                    displayValue: true
                });

                const element = {
                    id: Date.now().toString(),
                    type: 'image',
                    content: canvas.toDataURL(),
                    x: 50,
                    y: 50,
                    width: 200,
                    height: 100,
                    borderRadius: 0,
                    borderWidth: 0,
                    borderColor: '#000000',
                    filter: 'none',
                    boxShadow: false,
                    opacity: 1,
                    rotation: 0
                };

                state[state.activeSide].elements.push(element);
                state.selectedElement = element.id;
                saveToHistory();
                updateUI();
            } catch (err) {
                console.error("Barcode Error:", err);
                alert("Invalid barcode data");
            }

            input.value = '';
        }

        // Canvas Settings
        function changeCanvasBackground() {
            const color = document.getElementById('bgColorInput').value;
            state[state.activeSide].background = color;
            state[state.activeSide].backgroundImage = null;
            saveToHistory();
            updateUI();
        }

        // Canvas background color update from toolbar
        function updateCanvasBackground(color) {
            state[state.activeSide].background = color;
            state[state.activeSide].backgroundImage = null;
            document.getElementById('bgColorInput').value = color;
            saveToHistory();
            updateUI();
        }

        // Remove background image
        function removeBackgroundImage() {
            state[state.activeSide].backgroundImage = null;
            state[state.activeSide].background = '#ffffff';
            document.getElementById('bgColorInput').value = '#ffffff';
            saveToHistory();
            updateUI();
        }

        function addBackgroundImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                state[state.activeSide].backgroundImage = e.target.result;
                // Clear background color when using image
                state[state.activeSide].background = 'transparent';
                document.getElementById('bgColorInput').value = '#ffffff';
                saveToHistory();
                updateUI();
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        // Element Management
        function updateElement(id, updates) {
            const element = state[state.activeSide].elements.find(el => el.id === id);
            if (element) {
                Object.assign(element, updates);
                saveToHistory();
                updateUI();
            }
        }

        function deleteElement(id) {
            state[state.activeSide].elements = state[state.activeSide].elements.filter(el => el.id !== id);
            if (state.selectedElement === id) {
                state.selectedElement = null;
            }
            saveToHistory();
            updateUI();
        }

        function duplicateElement(id) {
            const element = state[state.activeSide].elements.find(el => el.id === id);
            if (element) {
                const newElement = JSON.parse(JSON.stringify(element));
                newElement.id = Date.now().toString();
                newElement.x += 20;
                newElement.y += 20;
                state[state.activeSide].elements.push(newElement);
                state.selectedElement = newElement.id;
                saveToHistory();
                updateUI();
            }
        }

        // Render Functions
        function renderCanvas() {
            const side = state.activeSide;
            const canvas = document.getElementById(side + 'Canvas');
            const canvasState = state[side];

            canvas.style.width = canvasState.width + 'px';
            canvas.style.height = canvasState.height + 'px';

            // Add vertical canvas class
            if (state.orientation === 'vertical') {
                canvas.classList.add('vertical-canvas');
            } else {
                canvas.classList.remove('vertical-canvas');
            }

            if (canvasState.backgroundImage) {
                canvas.style.backgroundImage = `url(${canvasState.backgroundImage})`;
                canvas.style.backgroundSize = 'cover';
                canvas.style.backgroundPosition = 'center';
                canvas.style.backgroundRepeat = 'no-repeat';
                canvas.style.backgroundColor = 'transparent';
            } else {
                canvas.style.backgroundImage = 'none';
                canvas.style.backgroundColor = canvasState.background;
            }

            canvas.innerHTML = '';

            canvasState.elements.forEach(element => {
                const div = document.createElement('div');
                div.className = 'canvas-element' + (state.selectedElement === element.id ? ' selected' : '');
                div.style.left = element.x + 'px';
                div.style.top = element.y + 'px';
                div.style.opacity = element.opacity || 1;
                div.style.transform = `rotate(${element.rotation || 0}deg)`;
                div.style.zIndex = state[state.activeSide].elements.indexOf(element);
                div.dataset.id = element.id;

                if (element.type === 'text') {
                    // Apply text styles
                    div.style.fontSize = element.fontSize + 'px';
                    div.style.color = element.color;
                    div.style.fontWeight = element.fontWeight;
                    div.style.fontStyle = element.fontStyle;
                    div.style.textTransform = element.textTransform;
                    div.style.textAlign = element.textAlign;
                    div.style.fontFamily = element.fontFamily || "'Inter', sans-serif";
                    div.style.letterSpacing = element.letterSpacing || 'normal';
                    div.style.lineHeight = element.lineHeight || 'normal';
                    div.style.textDecoration = element.textDecoration || 'none';
                    div.style.whiteSpace = 'pre-wrap';
                    div.style.width = element.width + 'px';
                    div.style.minWidth = '100px';
                    div.style.padding = (element.textPadding || 5) + 'px';

                    // Apply text background
                    if (element.textBackgroundColor !== 'transparent') {
                        div.style.backgroundColor = element.textBackgroundColor;
                        div.style.borderRadius = (element.textBorderRadius || 0) + 'px';
                        if (element.textBorderWidth > 0) {
                            div.style.border = `${element.textBorderWidth}px solid ${element.textBorderColor}`;
                        }
                    }

                    div.textContent = element.content;
                }
                else if (element.type === 'image') {
                    div.style.width = element.width + 'px';
                    div.style.height = element.height + 'px';
                    const img = document.createElement('img');
                    // Ensure image content has proper data URL format
                    let imgSrc = element.content;
                    if (imgSrc && !imgSrc.startsWith('data:')) {
                        imgSrc = 'data:image/png;base64,' + imgSrc;
                    }
                    img.src = imgSrc;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    img.style.borderRadius = (element.borderRadius || 0) + 'px';
                    img.style.border = `${element.borderWidth || 0}px solid ${element.borderColor || '#000'}`;

                    div.appendChild(img);
                }

                div.addEventListener('mousedown', (e) => onElementMouseDown(e, element.id));
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.selectedElement = element.id;
                    updateUI();
                });

                // Add resize handles for selected elements (except text)
                if (state.selectedElement === element.id && element.type !== 'text') {
                    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
                        const handle = document.createElement('div');
                        handle.className = 'resize-handle ' + corner;
                        handle.addEventListener('mousedown', (e) => onResizeMouseDown(e, element.id, corner));
                        div.appendChild(handle);
                    });
                }

                canvas.appendChild(div);
            });
        }

        function renderLayers() {
            const layersList = document.getElementById('layersList');
            const elements = state[state.activeSide].elements;

            document.getElementById('layerCount').textContent = elements.length;

            if (elements.length === 0) {
                layersList.innerHTML = '<div class="empty-state">No elements yet. Add some from the sidebar!</div>';
                return;
            }

            layersList.innerHTML = '';
            // Show in reverse order (top layers first)
            [...elements].reverse().forEach(element => {
                const div = document.createElement('div');
                div.className = 'layer-item' + (state.selectedElement === element.id ? ' selected' : '');
                div.onclick = () => {
                    state.selectedElement = element.id;
                    updateUI();
                };

                const icon = getElementIcon(element.type);
                const name = getElementLabel(element);

                div.innerHTML = `
                    <span class="layer-icon">${icon}</span>
                    <div class="layer-info">
                        <div class="layer-name">${name}</div>
                        <div class="layer-type">${element.type}</div>
                    </div>
                    <button class="layer-delete" onclick="event.stopPropagation(); deleteElement('${element.id}')">üóëÔ∏è</button>
                `;

                layersList.appendChild(div);
            });
        }

        function renderToolbar() {
            const noSelection = document.getElementById('noSelection');
            const properties = document.getElementById('elementProperties');

            const element = state[state.activeSide].elements.find(el => el.id === state.selectedElement);

            if (!element) {
                noSelection.classList.remove('hidden');
                properties.classList.add('hidden');
                return;
            }

            noSelection.classList.add('hidden');
            properties.classList.remove('hidden');

            let html = '';

            // Text Properties
            if (element.type === 'text') {
                html += `
                    <div class="property-group">
                        <div class="property-label">Content</div>
                        <input type="text" value="${element.content}" 
                            onchange="updateElement('${element.id}', {content: this.value})"
                            style="width:100%;padding:8px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:white;">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Font Family</div>
                        <select onchange="updateElement('${element.id}', {fontFamily: this.value})" style="width:100%">
                            <option value="'Inter', sans-serif" ${element.fontFamily === "'Inter', sans-serif" ? 'selected' : ''}>Inter</option>
                            <option value="'Roboto', sans-serif" ${element.fontFamily === "'Roboto', sans-serif" ? 'selected' : ''}>Roboto</option>
                            <option value="'Poppins', sans-serif" ${element.fontFamily === "'Poppins', sans-serif" ? 'selected' : ''}>Poppins</option>
                            <option value="'Montserrat', sans-serif" ${element.fontFamily === "'Montserrat', sans-serif" ? 'selected' : ''}>Montserrat</option>
                            <option value="'Open Sans', sans-serif" ${element.fontFamily === "'Open Sans', sans-serif" ? 'selected' : ''}>Open Sans</option>
                            <option value="Arial, sans-serif" ${element.fontFamily === "Arial, sans-serif" ? 'selected' : ''}>Arial</option>
                            <option value="'Times New Roman', serif" ${element.fontFamily === "'Times New Roman', serif" ? 'selected' : ''}>Times New Roman</option>
                            <option value="'Courier New', monospace" ${element.fontFamily === "'Courier New', monospace" ? 'selected' : ''}>Courier New</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Font Size</div>
                        <input type="range" min="12" max="120" value="${element.fontSize}" 
                            oninput="updateElement('${element.id}', {fontSize: parseInt(this.value)})">
                        <div class="range-value">${element.fontSize}px</div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Color</div>
                        <input type="color" value="${element.color}" 
                            onchange="updateElement('${element.id}', {color: this.value})">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Style</div>
                        <div class="style-buttons">
                            <button class="style-btn ${element.fontWeight === 'bold' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {fontWeight: '${element.fontWeight === 'bold' ? 'normal' : 'bold'}'})">
                                <strong>B</strong>
                            </button>
                            <button class="style-btn ${element.fontStyle === 'italic' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {fontStyle: '${element.fontStyle === 'italic' ? 'normal' : 'italic'}'})">
                                <em>I</em>
                            </button>
                            <button class="style-btn ${element.textTransform === 'uppercase' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textTransform: '${element.textTransform === 'uppercase' ? 'none' : 'uppercase'}'})">
                                Aa
                            </button>
                            <button class="style-btn ${element.textDecoration === 'underline' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textDecoration: '${element.textDecoration === 'underline' ? 'none' : 'underline'}'})">
                                UÃ≤
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Align</div>
                        <div class="style-buttons">
                            <button class="style-btn ${element.textAlign === 'left' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textAlign: 'left'})">‚Üê</button>
                            <button class="style-btn ${element.textAlign === 'center' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textAlign: 'center'})">‚Üî</button>
                            <button class="style-btn ${element.textAlign === 'right' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textAlign: 'right'})">‚Üí</button>
                            <button class="style-btn ${element.textAlign === 'justify' ? 'active' : ''}" 
                                onclick="updateElement('${element.id}', {textAlign: 'justify'})">‚é∏‚éπ</button>
                        </div>
                    </div>
                `;
            }

            // Image Properties
            if (element.type === 'image') {
                html += `
                    <div class="property-group">
                        <div class="property-label">Border Radius</div>
                        <input type="range" min="0" max="999" value="${element.borderRadius || 0}" 
                            oninput="updateElement('${element.id}', {borderRadius: parseInt(this.value)})">
                        <div class="range-value">${element.borderRadius || 0}px</div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Border</div>
                        <input type="range" min="0" max="20" value="${element.borderWidth || 0}" 
                            oninput="updateElement('${element.id}', {borderWidth: parseInt(this.value)})">
                        <div class="range-value">${element.borderWidth || 0}px</div>
                        <div class="color-picker-group" style="margin-top:5px;">
                            <span class="color-label">Color:</span>
                            <input type="color" value="${element.borderColor || '#000000'}" 
                                onchange="updateElement('${element.id}', {borderColor: this.value})" style="flex:1;">
                        </div>
                    </div>
                `;
            }

            // Universal Properties
            html += `
                <div class="property-group">
                    <div class="property-label">Opacity</div>
                    <input type="range" min="0" max="1" step="0.1" value="${element.opacity || 1}" 
                        oninput="updateElement('${element.id}', {opacity: parseFloat(this.value)})">
                    <div class="range-value">${Math.round((element.opacity || 1) * 100)}%</div>
                </div>
                <div class="property-group">
                    <div class="property-label">Rotation</div>
                    <input type="range" min="0" max="360" value="${element.rotation || 0}" 
                        oninput="updateElement('${element.id}', {rotation: parseInt(this.value)})">
                    <div class="range-value">${element.rotation || 0}¬∞</div>
                </div>
                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 16px 0; padding-top: 16px;">
                    <button class="action-btn duplicate" onclick="duplicateElement('${element.id}')">üìã Duplicate</button>
                    <button class="action-btn delete" onclick="deleteElement('${element.id}')">üóëÔ∏è Delete</button>
                </div>
            `;

            properties.innerHTML = html;
        }

        // Helper Functions
        function getElementIcon(type) {
            const icons = {
                text: 'üìù',
                image: 'üñºÔ∏è'
            };
            return icons[type] || 'üìÑ';
        }

        function getElementLabel(element) {
            if (element.type === 'text') {
                return element.content.substring(0, 20) + (element.content.length > 20 ? '...' : '');
            } else if (element.type === 'image') {
                // Check if it's QR or barcode
                if (element.content.includes('qrcode')) return 'QR Code';
                if (element.content.includes('canvas')) return 'Barcode';
                return 'Image';
            }
            return 'Element';
        }

        // Drag & Drop
        function onElementMouseDown(e, id) {
            if (e.target.classList.contains('resize-handle')) return;

            e.preventDefault();
            e.stopPropagation();

            isDragging = true;
            state.selectedElement = id;

            const element = state[state.activeSide].elements.find(el => el.id === id);
            const canvas = document.getElementById(state.activeSide + 'Canvas');
            const rect = canvas.getBoundingClientRect();

            dragStartX = e.clientX - rect.left - element.x;
            dragStartY = e.clientY - rect.top - element.y;

            updateUI();
        }

        function onResizeMouseDown(e, id, corner) {
            e.preventDefault();
            e.stopPropagation();

            isResizing = true;
            state.selectedElement = id;

            const element = state[state.activeSide].elements.find(el => el.id === id);

            resizeStartData = {
                id,
                corner,
                startX: e.clientX,
                startY: e.clientY,
                startWidth: element.width,
                startHeight: element.height,
                startPosX: element.x,
                startPosY: element.y
            };
        }

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const canvas = document.getElementById(state.activeSide + 'Canvas');
                const rect = canvas.getBoundingClientRect();
                const element = state[state.activeSide].elements.find(el => el.id === state.selectedElement);

                if (element) {
                    let newX = e.clientX - rect.left - dragStartX;
                    let newY = e.clientY - rect.top - dragStartY;

                    // Constrain within canvas
                    newX = Math.max(0, Math.min(newX, state[state.activeSide].width - (element.width || 50)));
                    newY = Math.max(0, Math.min(newY, state[state.activeSide].height - (element.height || 50)));

                    element.x = newX;
                    element.y = newY;
                    renderCanvas();
                }
            } else if (isResizing && resizeStartData) {
                const element = state[state.activeSide].elements.find(el => el.id === resizeStartData.id);
                if (element) {
                    const deltaX = e.clientX - resizeStartData.startX;
                    const deltaY = e.clientY - resizeStartData.startY;

                    let newWidth = resizeStartData.startWidth;
                    let newHeight = resizeStartData.startHeight;
                    let newX = resizeStartData.startPosX;
                    let newY = resizeStartData.startPosY;

                    if (resizeStartData.corner.includes('e')) {
                        newWidth = Math.max(30, resizeStartData.startWidth + deltaX);
                    }
                    if (resizeStartData.corner.includes('s')) {
                        newHeight = Math.max(30, resizeStartData.startHeight + deltaY);
                    }
                    if (resizeStartData.corner.includes('w')) {
                        newWidth = Math.max(30, resizeStartData.startWidth - deltaX);
                        newX = resizeStartData.startPosX + deltaX;
                    }
                    if (resizeStartData.corner.includes('n')) {
                        newHeight = Math.max(30, resizeStartData.startHeight - deltaY);
                        newY = resizeStartData.startPosY + deltaY;
                    }

                    // Constrain within canvas
                    newX = Math.max(0, Math.min(newX, state[state.activeSide].width - newWidth));
                    newY = Math.max(0, Math.min(newY, state[state.activeSide].height - newHeight));

                    element.width = newWidth;
                    element.height = newHeight;
                    element.x = newX;
                    element.y = newY;
                    renderCanvas();
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging || isResizing) {
                saveToHistory();
            }
            isDragging = false;
            isResizing = false;
            resizeStartData = null;
        });

        // High Quality Download Function
        async function downloadHighQuality(mode) {
            showLoading();

            const currentZoom = zoomLevel;
            zoomLevel = 1;
            updateZoomDisplay();

            const originalSide = state.activeSide;
            const originalSelected = state.selectedElement;

            try {
                // Calculate scale factor for high quality
                const scaleFactor = downloadQuality;

                if (mode === 'both') {
                    // Download both sides

                    // Download front side
                    state.activeSide = 'front';
                    state.selectedElement = null;
                    renderCanvas();
                    await new Promise(resolve => setTimeout(resolve, 200));

                    updateLoadingText('Processing front side...');
                    const frontCanvas = document.getElementById('frontCanvas');
                    const frontImage = await html2canvas(frontCanvas, {
                        backgroundColor: null,
                        scale: scaleFactor,
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        imageTimeout: 0,
                        onclone: function (clonedDoc) {
                            // Ensure all images are loaded
                            const imgs = clonedDoc.querySelectorAll('img');
                            imgs.forEach(img => {
                                img.crossOrigin = 'anonymous';
                            });
                        }
                    });

                    // Download back side
                    state.activeSide = 'back';
                    state.selectedElement = null;
                    renderCanvas();
                    await new Promise(resolve => setTimeout(resolve, 200));

                    updateLoadingText('Processing back side...');
                    const backCanvas = document.getElementById('backCanvas');
                    const backImage = await html2canvas(backCanvas, {
                        backgroundColor: null,
                        scale: scaleFactor,
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        imageTimeout: 0,
                        onclone: function (clonedDoc) {
                            const imgs = clonedDoc.querySelectorAll('img');
                            imgs.forEach(img => {
                                img.crossOrigin = 'anonymous';
                            });
                        }
                    });

                    updateLoadingText('Creating ZIP file...');
                    const zip = new JSZip();

                    // Add user info to ZIP
                    const userInfoStr = JSON.stringify(userInfo, null, 2);
                    zip.file("user-info.json", userInfoStr);

                    // Add front image to zip with highest quality
                    const frontDataUrl = frontImage.toDataURL('image/png', 1.0);
                    const frontBase64 = frontDataUrl.split(',')[1];
                    zip.file("id-card-front.png", frontBase64, { base64: true });

                    // Add back image to zip with highest quality
                    const backDataUrl = backImage.toDataURL('image/png', 1.0);
                    const backBase64 = backDataUrl.split(',')[1];
                    zip.file("id-card-back.png", backBase64, { base64: true });

                    updateLoadingText('Finalizing download...');
                    const content = await zip.generateAsync({
                        type: "blob",
                        compression: "STORE", // No compression for faster processing
                        compressionOptions: {
                            level: 0
                        }
                    });

                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = `id-card-${userInfo.fullName.replace(/\s+/g, '-')}-${scaleFactor}x-${Date.now()}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    alert(`Both sides downloaded successfully! Quality: ${scaleFactor}x`);

                } else if (mode === 'front' || mode === 'back') {
                    // Download single side
                    state.activeSide = mode;
                    state.selectedElement = null;
                    renderCanvas();
                    await new Promise(resolve => setTimeout(resolve, 200));

                    updateLoadingText(`Processing ${mode} side...`);
                    const canvas = document.getElementById(mode + 'Canvas');
                    const image = await html2canvas(canvas, {
                        backgroundColor: null,
                        scale: scaleFactor,
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        imageTimeout: 0,
                        onclone: function (clonedDoc) {
                            const imgs = clonedDoc.querySelectorAll('img');
                            imgs.forEach(img => {
                                img.crossOrigin = 'anonymous';
                            });
                        }
                    });

                    updateLoadingText('Creating image file...');
                    const link = document.createElement('a');
                    link.download = `id-card-${userInfo.fullName.replace(/\s+/g, '-')}-${mode}-${scaleFactor}x-${Date.now()}.png`;

                    // Create blob with maximum quality
                    image.toBlob(function (blob) {
                        const url = URL.createObjectURL(blob);
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);

                        alert(`${mode} side downloaded successfully! Quality: ${scaleFactor}x`);
                        hideLoading();
                    }, 'image/png', 1.0);

                    return; // Return early for blob download
                }

            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading canvas. Please try again with lower quality settings.');
            } finally {
                // Restore original state
                state.activeSide = originalSide;
                state.selectedElement = originalSelected;
                zoomLevel = currentZoom;
                updateZoomDisplay();
                renderCanvas();
                hideLoading();
            }
        }

        // Loading overlay functions
        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateLoadingText(text) {
            document.getElementById('loadingDetails').textContent = text;
        }

        // Modal functions for user info
        function showDownloadModal(mode) {
            currentDownloadMode = mode;
            loadSavedUserInfo();
            document.getElementById('userInfoModal').classList.add('active');
            validateForm();
        }

        function closeUserModal() {
            document.getElementById('userInfoModal').classList.remove('active');
            clearErrors();
            resetForm();
        }

        // Validation functions for user info modal
        function validateForm() {
            const fullName = document.getElementById('fullNameInput').value.trim();
            const phone = document.getElementById('phoneInput').value.trim();
            const address = document.getElementById('addressInput').value.trim();

            let isValid = true;

            // Validate full name
            const nameError = document.getElementById('nameError');
            const nameInput = document.getElementById('fullNameInput');
            if (fullName.length < 3) {
                nameError.classList.add('show');
                nameInput.classList.add('error');
                isValid = false;
            } else {
                nameError.classList.remove('show');
                nameInput.classList.remove('error');
            }

            // Validate phone number (10-15 digits)
            const phoneError = document.getElementById('phoneError');
            const phoneInput = document.getElementById('phoneInput');
            const phoneRegex = /^[0-9]{10,15}$/;
            if (!phoneRegex.test(phone)) {
                phoneError.classList.add('show');
                phoneInput.classList.add('error');
                isValid = false;
            } else {
                phoneError.classList.remove('show');
                phoneInput.classList.remove('error');
            }

            // Validate address
            const addressError = document.getElementById('addressError');
            const addressInput = document.getElementById('addressInput');
            if (address.length < 10) {
                addressError.classList.add('show');
                addressInput.classList.add('error');
                isValid = false;
            } else {
                addressError.classList.remove('show');
                addressInput.classList.remove('error');
            }

            // Enable/disable save button
            document.getElementById('saveBtn').disabled = !isValid;

            return isValid;
        }

        function clearErrors() {
            document.querySelectorAll('#userInfoModal .error-message').forEach(el => {
                el.classList.remove('show');
            });
            document.querySelectorAll('#userInfoModal .form-input').forEach(el => {
                el.classList.remove('error');
            });
        }

        function resetForm() {
            document.getElementById('fullNameInput').value = '';
            document.getElementById('phoneInput').value = '';
            document.getElementById('addressInput').value = '';
            document.getElementById('saveBtn').disabled = true;
        }

        function loadSavedUserInfo() {
            const savedInfo = localStorage.getItem('idCardUserInfo');
            if (savedInfo) {
                try {
                    const parsedInfo = JSON.parse(savedInfo);
                    document.getElementById('fullNameInput').value = parsedInfo.fullName || '';
                    document.getElementById('phoneInput').value = parsedInfo.phone || '';
                    document.getElementById('addressInput').value = parsedInfo.address || '';
                    validateForm();
                } catch (e) {
                    console.error('Error loading saved user info:', e);
                }
            }
        }

        function saveUserInfo() {
            if (!validateForm()) {
                return;
            }

            // Get user info from form
            userInfo = {
                fullName: document.getElementById('fullNameInput').value.trim(),
                phone: document.getElementById('phoneInput').value.trim(),
                address: document.getElementById('addressInput').value.trim()
            };

            // Save to localStorage
            try {
                localStorage.setItem('idCardUserInfo', JSON.stringify(userInfo));
                // Also save phone as app_id if not already set
                if (userInfo.phone && !localStorage.getItem('app_id')) {
                    localStorage.setItem('app_id', userInfo.phone);
                }
                console.log('User info saved to localStorage');
            } catch (e) {
                console.error('Error saving to localStorage:', e);
                alert('Warning: Could not save user info to browser storage.');
            }

            // Close modal
            closeUserModal();

            // Trigger the actual download
            if (currentDownloadMode) {
                downloadHighQuality(currentDownloadMode);
            }
        }

        // Initialize export modal event listeners
        function initExportModal() {
            // Template name input
            document.getElementById('templateNameInput').addEventListener('input', validateExportForm);
            
            // Service select
            document.getElementById('serviceSelect').addEventListener('change', validateExportForm);
            
            // Access type radio buttons
            document.querySelectorAll('input[name="accessType"]').forEach(radio => {
                radio.addEventListener('change', validateExportForm);
            });
            
            // Export type radio buttons
            document.querySelectorAll('input[name="exportType"]').forEach(radio => {
                radio.addEventListener('change', validateExportForm);
            });
            
            // Also add event listeners for radio options
            document.querySelectorAll('.radio-option').forEach(option => {
                option.addEventListener('click', function() {
                    const radioInput = this.querySelector('input[type="radio"]');
                    if (radioInput.name === 'accessType') {
                        selectRadio(this);
                    } else if (radioInput.name === 'exportType') {
                        selectExportType(this);
                    }
                });
            });
            
            // Handle Enter key in export modal
            document.getElementById('exportElementsModal').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleExportClick(e);
                }
            });
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', async function () {
            console.log('üöÄ DOM Content Loaded - Starting initialization');
            await init();
            loadSavedExportData();
            console.log('‚úÖ App initialization complete');
        });
    </script>
</body>
</html>
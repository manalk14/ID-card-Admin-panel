<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Professional ID Card Editor</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: linear-gradient(
          135deg,
          #0f172a 0%,
          #581c87 50%,
          #0f172a 100%
        );
        color: #fff;
        overflow: hidden;
        height: 100vh;
      }

      .app-container {
        display: flex;
        height: 100vh;
        width: 100%;
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: flex-start;
        justify-content: center;
        z-index: 10000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        overflow-y: auto;
        padding: 20px;
      }

      .modal-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .modal-container {
        background: linear-gradient(135deg, #1e293b 0%, #374151 100%);
        border-radius: 24px;
        padding: 32px;
        width: 90%;
        max-width: 500px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        transform: translateY(20px);
        transition: transform 0.3s ease;
        margin: 40px auto;
        max-height: 85vh;
        overflow-y: auto;
        position: relative;
      }

      .modal-container .modal-header {
        margin-bottom: 24px;
      }

      .modal-container .modal-title {
        font-size: 24px;
        font-weight: 700;
        color: white;
        margin-bottom: 8px;
      }

      .modal-container .modal-subtitle {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
      }

      .modal-container .form-group {
        margin-bottom: 20px;
      }

      .modal-container .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        margin-bottom: 8px;
      }

      .modal-container .required-indicator {
        color: #ef4444;
      }

      .modal-container .form-input {
        width: 100%;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        outline: none;
        transition: all 0.2s ease;
      }

      .modal-container .form-input.error {
        border-color: #ef4444;
      }

      .modal-container .error-message {
        font-size: 12px;
        color: #ef4444;
        margin-top: 4px;
        display: none;
      }

      .modal-container .error-message.show {
        display: block;
      }

      .modal-container .form-requirements {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 16px;
        margin: 20px 0;
      }

      .modal-container .requirements-title {
        font-size: 14px;
        font-weight: 600;
        color: white;
        margin-bottom: 8px;
      }

      .modal-container .requirement-item {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 4px;
      }

      .modal-container .modal-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
      }

      .modal-container .modal-btn {
        flex: 1;
        padding: 14px 20px;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
      }

      .modal-container .modal-btn.cancel {
        background: rgba(255, 255, 255, 0.1);
        color: white;
      }

      .modal-container .modal-btn.cancel:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .modal-container .modal-btn.save {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
      }

      .modal-container .modal-btn.save:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
      }

      .modal-container .modal-btn.save:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* Save Template Modal Styles */
      .save-template-modal .form-group {
        margin-bottom: 16px;
      }

      .save-template-modal .form-label {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 8px;
      }

      .save-template-modal .form-input {
        width: 100%;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 14px;
      }

      .save-template-modal .form-input:focus {
        border-color: #a78bfa;
        box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
      }

      .save-template-modal .radio-group {
        margin-top: 15px;
      }

      .save-template-modal .radio-option {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .save-template-modal .radio-option:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .save-template-modal .radio-option.selected {
        background: rgba(167, 139, 250, 0.2);
        border: 1px solid rgba(167, 139, 250, 0.5);
      }

      .save-template-modal .radio-option input[type="radio"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
      }

      .save-template-modal .radio-label {
        font-size: 14px;
        font-weight: 500;
      }

      /* Large data warning */
      .modal-container .large-data-warning {
        background: rgba(245, 158, 11, 0.1);
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 8px;
        padding: 12px;
        margin: 12px 0;
        font-size: 12px;
        color: #fbbf24;
      }

      .modal-container .large-data-warning ul {
        margin-left: 16px;
        margin-top: 4px;
      }

      .modal-container .large-data-warning li {
        margin-bottom: 2px;
      }

      /* Sidebar */
      .sidebar {
        width: 320px;
        min-width: 320px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(20px);
        border-right: 1px solid rgba(255, 255, 255, 0.1);
        padding: 24px;
        overflow-y: auto;
        height: 100vh;
        position: relative;
        z-index: 10;
      }

      .sidebar h1 {
        font-size: 28px;
        font-weight: 700;
        text-align: center;
        margin-bottom: 32px;
        background: linear-gradient(135deg, #a78bfa, #ec4899);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .section {
        margin-bottom: 24px;
      }

      .section-label {
        font-size: 12px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .side-toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 24px;
      }

      .side-btn {
        padding: 12px;
        border: none;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .side-btn.active {
        background: linear-gradient(135deg, #a78bfa, #ec4899);
        color: white;
        box-shadow: 0 8px 20px rgba(167, 139, 250, 0.4);
      }

      .side-btn:not(.active) {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
      }

      .side-btn:not(.active):hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .orientation-toggle {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .orientation-btn {
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.6);
      }

      .orientation-btn.active {
        background: #10b981;
        color: white;
      }

      .orientation-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .input-group {
        display: flex;
        gap: 8px;
      }

      input[type="text"] {
        flex: 1;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        outline: none;
        transition: all 0.2s ease;
      }

      input[type="text"]:focus {
        border-color: #a78bfa;
        box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
      }

      input[type="text"]::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }

      .add-btn {
        padding: 10px 16px;
        background: linear-gradient(135deg, #a78bfa, #ec4899);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .add-btn:hover {
        box-shadow: 0 8px 20px rgba(167, 139, 250, 0.4);
        transform: translateY(-2px);
      }

      .file-upload-btn {
        width: 100%;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s ease;
        display: block;
      }

      .file-upload-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      input[type="color"] {
        width: 100%;
        height: 48px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
      }

      select {
        width: 100%;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 14px;
        cursor: pointer;
        outline: none;
      }

      select option {
        background: #1e293b;
        color: white;
      }

      .divider {
        height: 1px;
        background: rgba(255, 255, 255, 0.1);
        margin: 20px 0;
      }

      /* Main Canvas Area */
      .canvas-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        overflow: hidden;
        height: 100vh;
        min-width: 0;
      }

      .canvas-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
        width: 100%;
        max-width: 1000px;
        padding: 10px 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        flex-shrink: 0;
      }

      .undo-redo-btn {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        font-size: 14px;
      }

      .undo-redo-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
      }

      .undo-redo-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .side-indicator {
        padding: 8px 20px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        font-weight: 600;
        white-space: nowrap;
        font-size: 14px;
      }

      /* Zoom Controls */
      .zoom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 6px 12px;
        border-radius: 8px;
        white-space: nowrap;
      }

      .zoom-btn {
        width: 32px;
        height: 32px;
        background: rgba(255, 255, 255, 0.15);
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .zoom-btn:hover {
        background: rgba(255, 255, 255, 0.25);
      }

      .zoom-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .zoom-level {
        color: white;
        font-weight: 600;
        font-size: 14px;
        min-width: 50px;
        text-align: center;
      }

      /* Canvas content area */
      .canvas-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        flex: 1;
        width: 100%;
        padding: 5px;
        overflow-y: auto;
        min-height: 0;
      }

      .canvas-wrapper {
        transition: transform 0.3s ease;
        transform-origin: center center;
        margin-bottom: 15px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 400px;
      }

      .canvas {
        position: relative;
        background: white;
        border-radius: 24px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }

      /* Vertical canvas specific */
      .canvas.vertical-canvas {
        max-height: 700px;
        margin: 10px auto;
      }

      .canvas-element {
        position: absolute;
        cursor: move;
        user-select: none;
      }

      .canvas-element.selected {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }

      .canvas-element img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
      }

      .resize-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background: #3b82f6;
        border: 2px solid white;
        border-radius: 50%;
        z-index: 10;
      }

      .resize-handle.nw {
        top: -6px;
        left: -6px;
        cursor: nw-resize;
      }

      .resize-handle.ne {
        top: -6px;
        right: -6px;
        cursor: ne-resize;
      }

      .resize-handle.sw {
        bottom: -6px;
        left: -6px;
        cursor: sw-resize;
      }

      .resize-handle.se {
        bottom: -6px;
        right: -6px;
        cursor: se-resize;
      }

      /* Download controls section */
      .download-controls-section {
        width: 70%;
        max-width: 1000px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        margin-top: 10px;
        flex-shrink: 0;
      }

      /* Quality Selector */
      .quality-selector {
        margin-bottom: 15px;
        width: 100%;
      }

      .quality-label {
        font-size: 12px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .quality-slider-container {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 12px 16px;
        border-radius: 12px;
      }

      .quality-slider {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .quality-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #a78bfa;
        cursor: pointer;
        border: 2px solid white;
      }

      .quality-value {
        color: white;
        font-weight: 600;
        font-size: 14px;
        min-width: 40px;
        text-align: center;
      }

      /* Download Options */
      .download-options {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
      }

      .download-option-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        white-space: nowrap;
        flex: 1;
        min-width: 120px;
      }

      .download-option-btn.both {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
      }

      .download-option-btn.front {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
      }

      .download-option-btn.back {
        background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        color: white;
      }

      .download-option-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      }

      .range-value {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        text-align: right;
        margin-top: 4px;
      }

      /* Right Panel */
      .right-panel {
        width: 320px;
        min-width: 320px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(20px);
        padding: 24px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 24px;
        height: 100vh;
        position: relative;
        z-index: 10;
      }

      .panel {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 20px;
      }

      .panel h3 {
        font-size: 18px;
        margin-bottom: 16px;
        color: white;
      }

      .property-group {
        margin-bottom: 16px;
      }

      .property-label {
        font-size: 11px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 6px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #a78bfa;
        cursor: pointer;
      }

      .style-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .style-btn {
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 8px;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        transition: all 0.2s ease;
        flex: 1;
        min-width: 60px;
      }

      .style-btn.active {
        background: #3b82f6;
        color: white;
      }

      .style-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .action-btn {
        width: 100%;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-bottom: 8px;
      }

      .action-btn.duplicate {
        background: #3b82f6;
        color: white;
      }

      .action-btn.delete {
        background: #ef4444;
        color: white;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .layer-item {
        padding: 12px;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid transparent;
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .layer-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .layer-item.selected {
        border-color: #3b82f6;
        background: rgba(59, 130, 246, 0.2);
      }

      .layer-info {
        flex: 1;
        min-width: 0;
      }

      .layer-icon {
        font-size: 20px;
        margin-right: 10px;
      }

      .layer-name {
        font-size: 14px;
        font-weight: 600;
        color: white;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .layer-type {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        text-transform: capitalize;
      }

      .layer-delete {
        padding: 6px;
        background: rgba(239, 68, 68, 0.2);
        border: none;
        border-radius: 6px;
        color: #ef4444;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .layer-delete:hover {
        background: rgba(239, 68, 68, 0.3);
      }

      .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: rgba(255, 255, 255, 0.5);
        font-size: 14px;
      }

      .hidden {
        display: none !important;
      }

      /* Canvas Size Section */
      .section label {
        display: block;
        font-size: 12px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 6px;
      }

      .section input[type="number"] {
        width: 100%;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
        color: #ffffff;
        font-size: 14px;
        outline: none;
        transition: all 0.25s ease;
      }

      /* Remove number arrows */
      .section input[type="number"]::-webkit-inner-spin-button,
      .section input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      .section input[type="number"]:focus {
        border-color: #a78bfa;
        box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.15);
      }

      /* Apply Size Button */
      .size-apply-btn {
        width: 100%;
        margin-top: 8px;
        padding: 12px;
        border-radius: 10px;
        background: linear-gradient(135deg, #a78bfa, #ec4899);
        color: #ffffff;
        font-weight: 700;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.25s ease;
        border: none;
      }

      .size-apply-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(167, 139, 250, 0.45);
      }

      .size-apply-btn:active {
        transform: scale(0.97);
      }

      .mt-5 {
        margin-top: 20px;
      }

      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        display: none;
      }

      .update-template-btn {
        width: 100%;
        padding: 12px;
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-top: 8px;
      }

      .update-template-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        border-top-color: #10b981;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      .loading-text {
        color: white;
        font-size: 18px;
        font-weight: 600;
      }

      .loading-details {
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        margin-top: 10px;
        text-align: center;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Size Warning */
      .size-warning {
        color: #fbbf24;
        font-size: 12px;
        margin-top: 8px;
        text-align: center;
        display: none;
      }

      /* Radio button styles for export modal */
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 8px;
      }

      .radio-option {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        padding: 10px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        transition: all 0.2s ease;
      }

      .radio-option:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .radio-option input[type="radio"] {
        width: 18px;
        height: 18px;
        accent-color: #a78bfa;
      }

      .radio-label {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.9);
      }

      .radio-option.selected {
        background: rgba(167, 139, 250, 0.2);
        border: 1px solid rgba(167, 139, 250, 0.5);
      }

      /* Back button */
      .backbtn {
        background-color: #4f46e5;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: 500;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        margin-bottom: 20px;
      }

      .backbtn:hover {
        background-color: #4338ca;
        transform: translateY(-2px);
      }

      .backbtn:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      /* Save Button in Sidebar */
      .save-template-btn {
        width: 100%;
        padding: 14px;
        background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        color: white;
        border: none;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-top: 16px;
        font-size: 15px;
      }

      .save-template-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
      }

      /* Responsive adjustments */
      @media (max-width: 1200px) {
        .app-container {
          flex-direction: column;
          height: auto;
          min-height: 100vh;
          overflow-y: auto;
        }

        .sidebar,
        .right-panel {
          width: 100%;
          min-width: 100%;
          height: auto;
          max-height: 400px;
        }

        .sidebar {
          border-right: none;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .right-panel {
          border-left: none;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .canvas-container {
          height: auto;
          min-height: 70vh;
        }

        .canvas-header {
          padding: 8px 10px;
          gap: 8px;
        }

        .undo-redo-btn,
        .side-indicator,
        .zoom-controls {
          font-size: 12px;
          padding: 6px 10px;
        }

        .zoom-btn {
          width: 28px;
          height: 28px;
          font-size: 14px;
        }

        .download-options {
          gap: 8px;
        }

        .download-option-btn {
          padding: 10px 15px;
          font-size: 12px;
          min-width: 100px;
        }
      }
    </style>
  </head>

  <body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">Processing</div>
      <div class="loading-details" id="loadingDetails">Please wait...</div>
    </div>

    <!-- Save Template Modal -->
    <div class="modal-overlay" id="saveTemplateModal">
      <div class="modal-container save-template-modal">
        <div class="modal-header">
          <div class="modal-title">Save Template Updates</div>
          <div class="modal-subtitle">
            Update your template with the current changes
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">
            <span>Template Name</span>
            <span class="required-indicator">*</span>
          </label>
          <input
            type="text"
            class="form-input"
            id="templateNameInput"
            placeholder="Enter template name"
          />
          <div class="error-message" id="templateNameError">
            Template name is required
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">
            <span>Save Options</span>
          </label>
          <div class="radio-group">
            <label class="radio-option" id="saveBothOption">
              <input type="radio" name="saveOption" value="both" checked />
              <span class="radio-label">Save Both Sides</span>
            </label>
            <label class="radio-option" id="saveFrontOption">
              <input type="radio" name="saveOption" value="front" />
              <span class="radio-label">Save Front Side Only</span>
            </label>
            <label class="radio-option" id="saveBackOption">
              <input type="radio" name="saveOption" value="back" />
              <span class="radio-label">Save Back Side Only</span>
            </label>
          </div>
        </div>

        <div class="form-requirements">
          <div class="requirements-title">‚ö†Ô∏è Important Notes:</div>
          <div class="requirement-item">
            ‚Ä¢ This will update the existing template in the database
          </div>
          <div class="requirement-item">
            ‚Ä¢ Original template ID: <strong id="currentTemplateId"></strong>
          </div>
          <div class="requirement-item">
            ‚Ä¢ App ID: <strong id="currentAppId"></strong>
          </div>
          <div class="requirement-item">
            ‚Ä¢ Elements to save: <span id="elementCount">0</span>
          </div>
        </div>

        <div class="large-data-warning">
          <strong>‚ö†Ô∏è Image Data Warning:</strong>
          <ul>
            <li>High-quality images will be converted to base64 format</li>
            <li>Large images may increase file size significantly</li>
            <li>Base64 data will be included in the JSON data</li>
            <li>Recommended canvas size: 700x450px or smaller</li>
          </ul>
        </div>

        <div class="modal-actions">
          <button class="modal-btn cancel" onclick="closeSaveTemplateModal()">
            Cancel
          </button>
          <button
            class="modal-btn save"
            id="saveTemplateBtn"
            onclick="saveTemplateUpdates()"
          >
            Save Updates
          </button>
        </div>
      </div>
    </div>

    <div class="app-container">
      <!-- Left Sidebar -->
      <div class="sidebar">
        <h1 id="appTitle">ID Card Editor</h1>

        <!-- Side Toggle -->
        <div class="side-toggle">
          <button
            class="side-btn active"
            id="frontSideBtn"
            onclick="switchSide('front')"
          >
            Front
          </button>
          <button
            class="side-btn"
            id="backSideBtn"
            onclick="switchSide('back')"
          >
            Back
          </button>
        </div>

        <!-- Zoom Controls -->
        <div class="section">
          <div class="section-label">üîç Canvas Zoom</div>
          <div class="zoom-controls" style="justify-content: center">
            <button class="zoom-btn" id="zoomOutBtn" onclick="zoomOut()">
              ‚àí
            </button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="zoom-btn" id="zoomInBtn" onclick="zoomIn()">
              +
            </button>
            <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">
              ‚Ü∫
            </button>
          </div>
        </div>

        <!-- Border Radius Style -->
        <div class="section">
          <div class="section-label">‚≠ï Border Radius</div>
          <input
            type="range"
            min="0"
            max="40"
            value="20"
            id="radiusRange"
            oninput="updateRadius(this.value)"
          />
          <div class="range-value"><span id="radiusValue">20</span> px</div>
        </div>

        <!-- Orientation Toggle -->
        <div class="section mt-5">
          <div class="section-label">üìê Card Orientation</div>
          <div class="orientation-toggle">
            <button
              class="orientation-btn active"
              id="horizontalBtn"
              onclick="setOrientation('horizontal')"
            >
              üóìÔ∏è Horizontal
            </button>
            <button
              class="orientation-btn"
              id="verticalBtn"
              onclick="setOrientation('vertical')"
            >
              üì± Vertical
            </button>
          </div>
        </div>

        <!-- Canvas Size Section -->
        <div class="section">
          <div class="section-label">üìè Canvas Size</div>
          <div class="input-group">
            <input
              type="number"
              id="canvasWidth"
              value="700"
              min="100"
              max="10000"
            />
            <input
              type="number"
              id="canvasHeight"
              value="450"
              min="100"
              max="10000"
            />
          </div>
          <button class="size-apply-btn" onclick="applyCanvasSize()">
            Apply Size
          </button>
          <div class="size-warning" id="sizeWarning">
            Large sizes will increase file size significantly
          </div>
        </div>

        <!-- Add Text -->
        <div class="section">
          <div class="section-label">üìù Add Text</div>
          <div class="input-group">
            <input
              type="text"
              id="textInput"
              placeholder="Enter text..."
              onkeypress="if (event.key === 'Enter') addCustomText();"
            />
            <button class="add-btn" onclick="addCustomText()">+</button>
          </div>
        </div>

        <!-- Add Image -->
        <div class="section">
          <div class="section-label">üñºÔ∏è Add Image</div>
          <label class="file-upload-btn">
            Upload Image
            <input
              type="file"
              accept="image/*"
              onchange="addImage(event)"
              style="display: none"
            />
          </label>
        </div>

        <!-- Canvas Background -->
        <div class="section">
          <div class="section-label">üé® Canvas Background</div>
          <input
            type="color"
            id="bgColorInput"
            value="#ffffff"
            onchange="changeCanvasBackground()"
          />
        </div>

        <!-- Background Image -->
        <div class="section">
          <div class="section-label">Background Image</div>
          <label class="file-upload-btn">
            Upload Background
            <input
              type="file"
              accept="image/*"
              onchange="addBackgroundImage(event)"
              style="display: none"
            />
          </label>
        </div>

        <!-- Save Template Button -->
        <button class="save-template-btn" onclick="openSaveTemplateModal()">
          üíæ Save Template Updates
        </button>
      </div>

      <!-- Canvas Area -->
      <div class="canvas-container">
        <!-- Canvas Header -->
        <div class="canvas-header">
          <button class="undo-redo-btn" id="undoBtn" onclick="undo()" disabled>
            ‚Ü∂ Undo
          </button>
          <button class="undo-redo-btn" id="redoBtn" onclick="redo()" disabled>
            ‚Ü∑ Redo
          </button>
          <div class="side-indicator" id="sideIndicator">üìÑ Front Side</div>
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoomOutBtn" onclick="zoomOut()">
              ‚àí
            </button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="zoom-btn" id="zoomInBtn" onclick="zoomIn()">
              +
            </button>
            <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom">
              ‚Ü∫
            </button>
          </div>
        </div>

        <!-- Canvas Content Area -->
        <div class="canvas-content-wrapper">
          <div class="canvas-wrapper" id="canvasWrapper">
            <div id="frontCanvas" class="canvas"></div>
            <div id="backCanvas" class="canvas hidden"></div>
          </div>
        </div>

        <!-- Download Controls Section -->
        <!-- <div class="download-controls-section"> -->
          <!-- Quality Selector -->
          <!-- <div class="quality-selector">
            <div class="quality-label">üéØ Download Quality</div>
            <div class="quality-slider-container">
              <input
                type="range"
                min="1"
                max="20"
                value="4"
                class="quality-slider"
                id="qualitySlider"
                oninput="updateQualityValue()"
              />
              <span class="quality-value" id="qualityValue">4x</span>
            </div>
            <div class="range-value">
              <span id="estimatedSize">Estimated: ~2 MB</span>
            </div>
          </div> -->

          <!-- Download Options -->
          <div class="download-options">
            <!-- <button
              class="download-option-btn both"
              onclick="downloadHighQuality('both')"
            >
              ‚¨á Both Sides (ZIP)
            </button>
            <button
              class="download-option-btn front"
              onclick="downloadHighQuality('front')"
            >
              ‚¨á Front Only
            </button>
            <button
              class="download-option-btn back"
              onclick="downloadHighQuality('back')"
            >
              ‚¨á Back Only
            </button>
          </div> -->
        </div>
      </div>

      <!-- Right Panel -->
      <div class="right-panel">
        <button class="backbtn" onclick="goBack()">Back</button>

        <!-- Toolbar -->
        <div class="panel" id="toolbarPanel">
          <h3>Element Properties</h3>
          <div id="noSelection" class="empty-state">
            Select an element to edit its properties
          </div>
          <div id="elementProperties" class="hidden"></div>
        </div>

        <!-- Layers -->
        <div class="panel">
          <h3>Layers (<span id="layerCount">0</span>)</h3>
          <div id="layersList"></div>
        </div>
      </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
      // API endpoint - Get from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const tempId = urlParams.get("tempId") || "MQ--";
      const appId = urlParams.get("appId") || "MQ--";
      const TEMPLATE_DETAILS_API =
        "http://192.168.20.103:80/skynetwork/admin/template-details.php";
      const UPDATE_TEMPLATE_API =
        "http://192.168.20.103:80/skynetwork/admin/action/templates.php";

      // Fixed Zoom functionality
      let zoomLevel = 1;
      const minZoom = 0.25;
      const maxZoom = 3;
      const zoomStep = 0.25;

      // Quality settings
      let downloadQuality = 4; // Default 4x scale

      // State Management
      let state = {
        front: {
          elements: [],
          background: "#ffffff",
          backgroundImage: null,
          width: 700,
          height: 450,
        },
        back: {
          elements: [],
          background: "#ffffff",
          backgroundImage: null,
          width: 700,
          height: 450,
        },
        activeSide: "front",
        selectedElement: null,
        orientation: "horizontal", // 'horizontal' or 'vertical'
        history: {
          front: [],
          back: [],
        },
        historyIndex: {
          front: -1,
          back: -1,
        },
      };

      let isDragging = false;
      let isResizing = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let resizeStartData = null;

      // Original template data for reference
      let originalTemplateData = null;

      // Function to call API on page load
      async function callTemplateAPI() {
        console.log("üîÑ Calling template API...");

        // Prepare the data to send using URL parameters
        const requestData = {
          app_id: appId,
          tempid: tempId,
        };

        console.log("üì§ Sending request data:", requestData);

        try {
          showLoading();
          updateLoadingText("Fetching template data from API...");

          // Make the API call
          const response = await fetch(TEMPLATE_DETAILS_API, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(requestData),
          });

          console.log("üì• Response status:", response.status);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const responseText = await response.text();
          console.log("üì• Raw response:", responseText);

          // Try to parse JSON response
          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            console.error("Failed to parse response as JSON:", parseError);
            throw new Error("Invalid JSON response from server");
          }

          console.log("‚úÖ Parsed API Response:", data);

          // Store original template data
          originalTemplateData = data;

          // Display the response in console
          console.log("üéØ Full API Response Object:", data);

          // Load the data into canvas
          updateLoadingText("Loading template into editor...");
          const success = await loadAPIDataIntoCanvas(data);

          if (success) {
            hideLoading();
            console.log(
              `‚úÖ Template loaded successfully! Front: ${state.front.elements.length} elements, Back: ${state.back.elements.length} elements`,
            );
          } else {
            hideLoading();
            console.log(
              "‚ö†Ô∏è Template loaded but some elements may not be displayed correctly.",
            );
          }

          return data;
        } catch (error) {
          console.error("‚ùå API Error:", error);
          hideLoading();
          console.log(
            `‚ùå Error calling API: ${error.message}\n\nUsing default template instead.`,
          );

          // Load default template or show empty canvas
          loadDefaultTemplate();
          return null;
        }
      }

      // Function to load API data into canvas
      async function loadAPIDataIntoCanvas(apiData) {
        try {
          console.log("üîÑ Processing API data for canvas...", apiData);

          // Reset current state
          state.front.elements = [];
          state.back.elements = [];
          state.selectedElement = null;

          if (!apiData) {
            console.warn("No API data provided");
            return false;
          }

          // Check if we have templates array
          if (apiData.templates && Array.isArray(apiData.templates)) {
            // Take the first template
            const template = apiData.templates[0];
            console.log("üìã Found template:", template);

            if (template.json_data) {
              let jsonData = template.json_data;

              // If json_data is a string, parse it
              if (typeof jsonData === "string") {
                try {
                  jsonData = JSON.parse(jsonData);
                } catch (e) {
                  console.error("Failed to parse json_data string:", e);
                  return false;
                }
              }

              console.log("üìä Parsed json_data:", jsonData);

              // üîπ STEP 1: Apply canvas size
              if (jsonData.canvasSize) {
                state.front.width = parseInt(jsonData.canvasSize.width) || 700;
                state.front.height =
                  parseInt(jsonData.canvasSize.height) || 450;
              } else if (jsonData.width && jsonData.height) {
                state.front.width = parseInt(jsonData.width) || 700;
                state.front.height = parseInt(jsonData.height) || 450;
              } else {
                state.front.width = 700;
                state.front.height = 450;
              }
              state.back.width = state.front.width;
              state.back.height = state.front.height;

              document.getElementById("canvasWidth").value = state.front.width;
              document.getElementById("canvasHeight").value =
                state.front.height;

              // üîπ STEP 2: Apply background
              state.front.background = "#ffffff";
              state.back.background = "#ffffff";
              document.getElementById("bgColorInput").value =
                state.front.background;

              // üîπ STEP 3: Load elements
              if (jsonData.elements) {
                // Load front elements
                if (
                  jsonData.elements.front &&
                  Array.isArray(jsonData.elements.front)
                ) {
                  jsonData.elements.front.forEach((el) => {
                    const element = processAPIElement(el);
                    if (element) {
                      state.front.elements.push(element);
                      console.log("‚úÖ Added front element:", element);
                    }
                  });
                }

                // Load back elements
                if (
                  jsonData.elements.back &&
                  Array.isArray(jsonData.elements.back)
                ) {
                  jsonData.elements.back.forEach((el) => {
                    const element = processAPIElement(el);
                    if (element) {
                      state.back.elements.push(element);
                      console.log("‚úÖ Added back element:", element);
                    }
                  });
                }
              } else if (Array.isArray(jsonData)) {
                // If json_data is directly an array
                jsonData.forEach((el) => {
                  const element = processAPIElement(el);
                  if (element) {
                    state.front.elements.push(element);
                    console.log("‚úÖ Added element:", element);
                  }
                });
              }
            }
          } else {
            console.warn("No templates found in API response");
            // Try alternative structure
            if (apiData.json_data) {
              const element = processAPIElement(apiData);
              if (element) {
                state.front.elements.push(element);
              }
            }
          }

          // üîπ STEP 4: Toggle back side button
          document.getElementById("backSideBtn").style.display =
            state.back.elements.length > 0 ? "block" : "none";

          // üîπ STEP 5: Finalize
          saveToHistory();
          updateUI();
          //updateEstimatedSize();

          console.log("‚úÖ Template loaded successfully");
          console.log("üìä Front elements:", state.front.elements.length);
          console.log("üìä Back elements:", state.back.elements.length);

          return true;
        } catch (error) {
          console.error("‚ùå Error loading API data into canvas:", error);
          return false;
        }
      }

      // Function to process API element data - FIXED VERSION
      function processAPIElement(elementData) {
        try {
          console.log("Processing element:", elementData);

          // Create a unique ID - use existing ID if available
          const elementId = elementData.id || Date.now().toString();

          // Determine element type
          let elementType = elementData.type || "text";

          // Create base element structure
          const element = {
            id: elementId,
            type: elementType,
            x: parseInt(elementData.x) || 50,
            y: parseInt(elementData.y) || 50,
            width: parseInt(elementData.width) || 150,
            height: parseInt(elementData.height) || 150,
            rotation: parseInt(elementData.rotation) || 0,
            opacity: parseFloat(elementData.opacity) || 1,
          };

          if (elementType === "text") {
            // Text element properties
            element.content = elementData.content || "Sample Text";
            element.fontSize = parseInt(elementData.fontSize) || 24;
            element.color = elementData.color || "#333333";
            element.fontFamily =
              elementData.fontFamily || "'Inter', sans-serif";
            element.fontWeight = elementData.fontWeight || "normal";
            element.fontStyle = elementData.fontStyle || "normal";
            element.textAlign = elementData.textAlign || "left";
            element.textTransform = elementData.textTransform || "none";
            element.textDecoration = elementData.textDecoration || "none";
            element.letterSpacing = elementData.letterSpacing || "normal";
            element.lineHeight = elementData.lineHeight || "normal";
            element.textBackgroundColor =
              elementData.textBackgroundColor || "transparent";
            element.textBorderWidth =
              parseInt(elementData.textBorderWidth) || 0;
            element.textBorderColor = elementData.textBorderColor || "#000000";
            element.textBorderRadius =
              parseInt(elementData.textBorderRadius) || 0;
            element.textPadding = parseInt(elementData.textPadding) || 5;
            element.textShadow = elementData.textShadow || "";
          } else if (elementType === "image") {
            // CRITICAL FIX: Handle image content properly
            let imgSrc =
              elementData.content ||
              elementData.image_url ||
              elementData.image_base64;

            console.log(
              "Image content received:",
              imgSrc ? imgSrc.substring(0, 100) + "..." : "empty",
            );

            if (!imgSrc) {
              // No image data at all
              element.content = createPlaceholderImage("No Image");
            } else if (imgSrc.startsWith("data:image/")) {
              // It's already a data URL
              // Check if it's malformed (like "data:image/png;base64,,")
              if (imgSrc.includes("base64,,") || imgSrc.endsWith(",,")) {
                console.warn("Malformed base64 data URL detected");
                element.content = createPlaceholderImage("Invalid Image Data");
              } else {
                element.content = imgSrc;
              }
            } else if (imgSrc.length > 100) {
              // Assume it's raw base64 without data URL prefix
              // Try to detect image type
              let mimeType = "image/png";
              if (imgSrc.charAt(0) === "/") mimeType = "image/jpeg";
              if (imgSrc.charAt(0) === "R") mimeType = "image/gif";
              if (imgSrc.charAt(0) === "i") mimeType = "image/png";

              element.content = `data:${mimeType};base64,${imgSrc}`;
            } else if (imgSrc.startsWith("http")) {
              // It's a URL
              element.content = imgSrc;
            } else {
              // Unknown format
              element.content = createPlaceholderImage("Invalid Format");
            }

            // Add image-specific properties
            element.borderRadius = parseInt(elementData.borderRadius) || 0;
            element.borderWidth = parseInt(elementData.borderWidth) || 0;
            element.borderColor = elementData.borderColor || "#000000";
            element.filter = elementData.filter || "none";
            element.boxShadow = elementData.boxShadow || false;
          }

          console.log("Processed element:", element);
          return element;
        } catch (error) {
          console.error("Error processing API element:", error, elementData);
          return null;
        }
      }

      // Helper function to create placeholder image
      function createPlaceholderImage(text = "Image") {
        const svgString = `
                <svg xmlns="http://www.w3.org/2000/svg" width="150" height="150" viewBox="0 0 150 150">
                    <rect width="150" height="150" fill="#374151"/>
                    <text x="75" y="70" font-family="Arial, sans-serif" font-size="14" fill="white" text-anchor="middle" font-weight="bold">${text}</text>
                    <text x="75" y="90" font-family="Arial, sans-serif" font-size="10" fill="#a78bfa" text-anchor="middle">Click to edit</text>
                    <path d="M30,110 L120,110 M75,85 L75,135" stroke="#a78bfa" stroke-width="2" fill="none"/>
                </svg>
            `;
        return (
          "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString)
        );
      }

      // Function to load default template
      function loadDefaultTemplate() {
        console.log("üìÑ Loading default template...");

        // Reset to default state
        state.front.elements = [];
        state.back.elements = [];
        state.front.background = "#ffffff";
        state.back.background = "#ffffff";
        state.front.width = 700;
        state.front.height = 450;
        state.back.width = 700;
        state.back.height = 450;

        // Add some default elements
        addText("ID CARD");
        addText("Name: John Doe");
        addText("Position: Developer");

        saveToHistory();
        updateUI();
        //updateEstimatedSize();
      }

      // Initialize function
      async function init() {
        console.log("üöÄ Initializing ID Card Editor...");
        console.log("üìù URL Parameters:", { tempId, appId });

        // Call the API when page loads
        await callTemplateAPI();

        // Initialize the editor
        saveToHistory();
        updateUI();
        updateZoomDisplay();
        //updateQualityValue();

        // Click outside elements to deselect
        document.addEventListener("click", (e) => {
          if (e.target.classList.contains("canvas")) {
            state.selectedElement = null;
            updateUI();
          }
        });

        // Prevent form submission
        document.querySelectorAll("form").forEach((form) => {
          form.addEventListener("submit", function (e) {
            e.preventDefault();
          });
        });

        console.log("‚úÖ Initialization complete");
      }

      function goBack() {
        window.location.href = "template.html";
      }

      // Update UI function
      function updateUI() {
        renderCanvas();
        renderLayers();
        renderToolbar();
        updateUndoRedoButtons();
        //updateEstimatedSize();
      }

      // Update zoom display
      function updateZoomDisplay() {
        document.getElementById("zoomLevel").textContent =
          Math.round(zoomLevel * 100) + "%";
        document.getElementById("canvasWrapper").style.transform =
          `scale(${zoomLevel})`;

        // Disable buttons at limits
        document.getElementById("zoomOutBtn").disabled = zoomLevel <= minZoom;
        document.getElementById("zoomInBtn").disabled = zoomLevel >= maxZoom;
      }

      // Update quality value display
      // function updateQualityValue() {
      //   downloadQuality = parseInt(
      //     document.getElementById("qualitySlider").value,
      //   );
      //   document.getElementById("qualityValue").textContent =
      //     downloadQuality + "x";
      //   //updateEstimatedSize();
      // }

      // Update estimated file size
      // function updateEstimatedSize() {
      //   const side = state.activeSide;
      //   const canvasState = state[side];
      //   const baseSize = (canvasState.width * canvasState.height) / 1000000; // MP
      //   const scaledSize = baseSize * (downloadQuality * downloadQuality);
      //   const estimatedSizeMB = Math.min(scaledSize * 0.5, 1024); // Conservative estimate
      //   const estimatedSizeGB = estimatedSizeMB / 1024;

      //   let sizeText;
      //   if (estimatedSizeGB >= 1) {
      //     sizeText = `Estimated: ~${estimatedSizeGB.toFixed(1)} GB`;
      //   } else {
      //     sizeText = `Estimated: ~${Math.round(estimatedSizeMB)} MB`;
      //   }

      //   document.getElementById("estimatedSize").textContent = sizeText;

      //   // Show warning for large sizes
      //   const warning = document.getElementById("sizeWarning");
      //   if (scaledSize > 100) {
      //     warning.style.display = "block";
      //   } else {
      //     warning.style.display = "none";
      //   }
      // }

      // Zoom in
      function zoomIn() {
        if (zoomLevel < maxZoom) {
          zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
          updateZoomDisplay();
        }
      }

      // Zoom out
      function zoomOut() {
        if (zoomLevel > minZoom) {
          zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
          updateZoomDisplay();
        }
      }

      // Reset zoom
      function resetZoom() {
        zoomLevel = 1;
        updateZoomDisplay();
      }

      // Canvas border radius
      function updateRadius(value) {
        document.querySelectorAll(".canvas").forEach((canvas) => {
          canvas.style.borderRadius = value + "px";
        });
        document.getElementById("radiusValue").innerText = value;
      }

      // Orientation Management
      function setOrientation(orientation) {
        state.orientation = orientation;

        // Update UI buttons
        document
          .getElementById("horizontalBtn")
          .classList.toggle("active", orientation === "horizontal");
        document
          .getElementById("verticalBtn")
          .classList.toggle("active", orientation === "vertical");

        // Update size based on orientation
        if (orientation === "vertical") {
          setCanvasSize(450, 700);
        } else {
          setCanvasSize(700, 450);
        }
      }

      // Unified canvas size function
      function setCanvasSize(width, height) {
        // Update both sides
        ["front", "back"].forEach((side) => {
          state[side].width = width;
          state[side].height = height;
        });

        // Update manual input fields
        document.getElementById("canvasWidth").value = width;
        document.getElementById("canvasHeight").value = height;

        saveToHistory();
        updateUI();
        //updateEstimatedSize();
      }

      // Apply manual size
      function applyCanvasSize() {
        let w = parseInt(document.getElementById("canvasWidth").value);
        let h = parseInt(document.getElementById("canvasHeight").value);

        if (w <= 0 || h <= 0 || isNaN(w) || isNaN(h)) {
          alert("Please enter valid width and height (greater than 0)");
          return;
        }

        if (w > 10000 || h > 10000) {
          if (
            !confirm(
              "Sizes above 10000px may cause performance issues. Continue?",
            )
          ) {
            return;
          }
        }

        setCanvasSize(w, h);
      }

      // History Management
      function saveToHistory() {
        const side = state.activeSide;
        const currentState = JSON.parse(JSON.stringify(state[side]));

        state.history[side] = state.history[side].slice(
          0,
          state.historyIndex[side] + 1,
        );
        state.history[side].push(currentState);
        state.historyIndex[side] = state.history[side].length - 1;

        updateUndoRedoButtons();
      }

      function undo() {
        const side = state.activeSide;
        if (state.historyIndex[side] > 0) {
          state.historyIndex[side]--;
          state[side] = JSON.parse(
            JSON.stringify(state.history[side][state.historyIndex[side]]),
          );
          state.selectedElement = null;
          updateUI();
          updateUndoRedoButtons();
        }
      }

      function redo() {
        const side = state.activeSide;
        if (state.historyIndex[side] < state.history[side].length - 1) {
          state.historyIndex[side]++;
          state[side] = JSON.parse(
            JSON.stringify(state.history[side][state.historyIndex[side]]),
          );
          state.selectedElement = null;
          updateUI();
          updateUndoRedoButtons();
        }
      }

      function updateUndoRedoButtons() {
        const side = state.activeSide;
        document.getElementById("undoBtn").disabled =
          state.historyIndex[side] <= 0;
        document.getElementById("redoBtn").disabled =
          state.historyIndex[side] >= state.history[side].length - 1;
      }

      // Side Management
      function switchSide(side) {
        state.activeSide = side;
        state.selectedElement = null;

        // Update UI
        document
          .getElementById("frontSideBtn")
          .classList.toggle("active", side === "front");
        document
          .getElementById("backSideBtn")
          .classList.toggle("active", side === "back");
        document
          .getElementById("frontCanvas")
          .classList.toggle("hidden", side !== "front");
        document
          .getElementById("backCanvas")
          .classList.toggle("hidden", side !== "back");
        document.getElementById("sideIndicator").textContent =
          side === "front" ? "üìÑ Front Side" : "üìÑ Back Side";

        updateUI();
        updateUndoRedoButtons();
      }

      // Add Elements
      function addText(text) {
        if (!text) return;
        const element = {
          id: Date.now().toString(),
          type: "text",
          content: text,
          x: 50,
          y: 50,
          fontSize: 24,
          color: "#333333",
          fontWeight: "normal",
          fontStyle: "normal",
          textTransform: "none",
          textAlign: "left",
          textShadow: "",
          opacity: 1,
          width: 250,
          rotation: 0,
          fontFamily: "Inter, sans-serif",
          letterSpacing: "normal",
          lineHeight: "normal",
          textDecoration: "none",
          textBackgroundColor: "transparent",
          textBorderWidth: 0,
          textBorderColor: "#000000",
          textBorderRadius: 0,
          textPadding: 5,
        };
        state[state.activeSide].elements.push(element);
        state.selectedElement = element.id;
        saveToHistory();
        updateUI();
      }

      function addCustomText() {
        const input = document.getElementById("textInput");
        if (input.value.trim()) {
          addText(input.value);
          input.value = "";
        }
      }

      function addImage(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Validate file
        if (!file.type.startsWith("image/")) {
          alert("Please select an image file");
          event.target.value = "";
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const element = {
            id: Date.now().toString(),
            type: "image",
            content: e.target.result,
            x: 50,
            y: 50,
            width: 140,
            height: 160,
            borderRadius: 0,
            borderWidth: 0,
            borderColor: "#000000",
            filter: "none",
            boxShadow: false,
            opacity: 1,
            rotation: 0,
          };
          state[state.activeSide].elements.push(element);
          state.selectedElement = element.id;
          saveToHistory();
          updateUI();
        };
        reader.readAsDataURL(file);
        event.target.value = "";
      }

      // Canvas Settings
      function changeCanvasBackground() {
        const color = document.getElementById("bgColorInput").value;
        state[state.activeSide].background = color;
        state[state.activeSide].backgroundImage = null;
        saveToHistory();
        updateUI();
      }

      function addBackgroundImage(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Validate file
        if (!file.type.startsWith("image/")) {
          alert("Please select an image file");
          event.target.value = "";
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          state[state.activeSide].backgroundImage = e.target.result;
          // Clear background color when using image
          state[state.activeSide].background = "transparent";
          document.getElementById("bgColorInput").value = "#ffffff";
          saveToHistory();
          updateUI();
        };
        reader.readAsDataURL(file);
        event.target.value = "";
      }

      // Element Management
      function updateElement(id, updates) {
        const element = state[state.activeSide].elements.find(
          (el) => el.id === id,
        );
        if (element) {
          Object.assign(element, updates);
          saveToHistory();
          updateUI();
        }
      }

      function deleteElement(id) {
        state[state.activeSide].elements = state[
          state.activeSide
        ].elements.filter((el) => el.id !== id);
        if (state.selectedElement === id) {
          state.selectedElement = null;
        }
        saveToHistory();
        updateUI();
      }

      function duplicateElement(id) {
        const element = state[state.activeSide].elements.find(
          (el) => el.id === id,
        );
        if (element) {
          const newElement = JSON.parse(JSON.stringify(element));
          newElement.id = Date.now().toString();
          newElement.x += 20;
          newElement.y += 20;
          state[state.activeSide].elements.push(newElement);
          state.selectedElement = newElement.id;
          saveToHistory();
          updateUI();
        }
      }

      // Render Functions - CRITICAL FIX for image rendering
      function renderCanvas() {
        const side = state.activeSide;
        const canvas = document.getElementById(side + "Canvas");
        const canvasState = state[side];

        canvas.style.width = canvasState.width + "px";
        canvas.style.height = canvasState.height + "px";

        // Add vertical canvas class
        if (state.orientation === "vertical") {
          canvas.classList.add("vertical-canvas");
        } else {
          canvas.classList.remove("vertical-canvas");
        }

        if (canvasState.backgroundImage) {
          canvas.style.backgroundImage = `url(${canvasState.backgroundImage})`;
          canvas.style.backgroundSize = "cover";
          canvas.style.backgroundPosition = "center";
          canvas.style.backgroundRepeat = "no-repeat";
          canvas.style.backgroundColor = "transparent";
        } else {
          canvas.style.backgroundImage = "none";
          canvas.style.backgroundColor = canvasState.background;
        }

        canvas.innerHTML = "";

        canvasState.elements.forEach((element) => {
          const div = document.createElement("div");
          div.className =
            "canvas-element" +
            (state.selectedElement === element.id ? " selected" : "");
          div.style.left = element.x + "px";
          div.style.top = element.y + "px";
          div.style.opacity = element.opacity || 1;
          div.style.transform = `rotate(${element.rotation || 0}deg)`;
          div.style.zIndex = state[state.activeSide].elements.indexOf(element);
          div.dataset.id = element.id;

          if (element.type === "text") {
            // Apply text styles
            div.style.fontSize = element.fontSize + "px";
            div.style.color = element.color;
            div.style.fontWeight = element.fontWeight;
            div.style.fontStyle = element.fontStyle;
            div.style.textTransform = element.textTransform;
            div.style.textAlign = element.textAlign;
            div.style.fontFamily = element.fontFamily || "'Inter', sans-serif";
            div.style.letterSpacing = element.letterSpacing || "normal";
            div.style.lineHeight = element.lineHeight || "normal";
            div.style.textDecoration = element.textDecoration || "none";
            div.style.whiteSpace = "pre-wrap";
            div.style.width = element.width + "px";
            div.style.minWidth = "100px";
            div.style.padding = (element.textPadding || 5) + "px";

            // Apply text background
            if (element.textBackgroundColor !== "transparent") {
              div.style.backgroundColor = element.textBackgroundColor;
              div.style.borderRadius = (element.textBorderRadius || 0) + "px";
              if (element.textBorderWidth > 0) {
                div.style.border = `${element.textBorderWidth}px solid ${element.textBorderColor}`;
              }
            }

            div.textContent = element.content;
          } else if (element.type === "image") {
            div.style.width = element.width + "px";
            div.style.height = element.height + "px";
            const img = document.createElement("img");

            // CRITICAL FIX: Handle image source properly
            let imgSrc = element.content;

            console.log(
              "Rendering image with src:",
              imgSrc ? imgSrc.substring(0, 100) + "..." : "empty",
            );

            // Validate the image source
            if (
              !imgSrc ||
              imgSrc === "data:image/png;base64,," ||
              imgSrc.includes("base64,,")
            ) {
              // Invalid or empty base64 data
              console.warn("Invalid image data detected, using placeholder");
              imgSrc = createPlaceholderImage("Invalid Image");
            } else if (imgSrc.startsWith("data:image/")) {
              // It's already a valid data URL, use it as is
              // Nothing to do here
            } else if (imgSrc.length > 100 && !imgSrc.startsWith("http")) {
              // Assume it's raw base64
              imgSrc = "data:image/png;base64," + imgSrc;
            }

            img.src = imgSrc;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            img.style.borderRadius = (element.borderRadius || 0) + "px";
            img.style.border = `${element.borderWidth || 0}px solid ${
              element.borderColor || "#000"
            }`;

            // Handle image load error
            img.onerror = function () {
              console.error("Failed to load image, using placeholder");
              this.src = createPlaceholderImage("Load Failed");
              this.onerror = null; // Prevent infinite loop
            };

            div.appendChild(img);
          }

          div.addEventListener("mousedown", (e) =>
            onElementMouseDown(e, element.id),
          );
          div.addEventListener("click", (e) => {
            e.stopPropagation();
            state.selectedElement = element.id;
            updateUI();
          });

          // Add resize handles for selected elements (except text)
          if (state.selectedElement === element.id && element.type !== "text") {
            ["nw", "ne", "sw", "se"].forEach((corner) => {
              const handle = document.createElement("div");
              handle.className = "resize-handle " + corner;
              handle.addEventListener("mousedown", (e) =>
                onResizeMouseDown(e, element.id, corner),
              );
              div.appendChild(handle);
            });
          }

          canvas.appendChild(div);
        });
      }

      function renderLayers() {
        const layersList = document.getElementById("layersList");
        const elements = state[state.activeSide].elements;

        document.getElementById("layerCount").textContent = elements.length;

        if (elements.length === 0) {
          layersList.innerHTML =
            '<div class="empty-state">No elements yet. Add some from the sidebar!</div>';
          return;
        }

        layersList.innerHTML = "";
        // Show in reverse order (top layers first)
        [...elements].reverse().forEach((element) => {
          const div = document.createElement("div");
          div.className =
            "layer-item" +
            (state.selectedElement === element.id ? " selected" : "");
          div.onclick = () => {
            state.selectedElement = element.id;
            updateUI();
          };

          const icon = getElementIcon(element.type);
          const name = getElementLabel(element);

          div.innerHTML = `
                    <span class="layer-icon">${icon}</span>
                    <div class="layer-info">
                        <div class="layer-name">${name}</div>
                        <div class="layer-type">${element.type}</div>
                    </div>
                    <button class="layer-delete" onclick="event.stopPropagation(); deleteElement('${element.id}')">üóëÔ∏è</button>
                `;

          layersList.appendChild(div);
        });
      }

      function renderToolbar() {
        const noSelection = document.getElementById("noSelection");
        const properties = document.getElementById("elementProperties");

        const element = state[state.activeSide].elements.find(
          (el) => el.id === state.selectedElement,
        );

        if (!element) {
          noSelection.classList.remove("hidden");
          properties.classList.add("hidden");
          return;
        }

        noSelection.classList.add("hidden");
        properties.classList.remove("hidden");

        let html = "";

        // Text Properties
        if (element.type === "text") {
          html += `
                    <div class="property-group">
                        <div class="property-label">Content</div>
                        <input type="text" value="${element.content}" 
                            onchange="updateElement('${element.id}', {content: this.value})"
                            style="width:100%;padding:8px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:white;">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Font Family</div>
                        <select onchange="updateElement('${element.id}', {fontFamily: this.value})" style="width:100%">
                            <option value="'Inter', sans-serif" ${
                              element.fontFamily === "'Inter', sans-serif"
                                ? "selected"
                                : ""
                            }>Inter</option>
                            <option value="'Roboto', sans-serif" ${
                              element.fontFamily === "'Roboto', sans-serif"
                                ? "selected"
                                : ""
                            }>Roboto</option>
                            <option value="'Poppins', sans-serif" ${
                              element.fontFamily === "'Poppins', sans-serif"
                                ? "selected"
                                : ""
                            }>Poppins</option>
                            <option value="'Montserrat', sans-serif" ${
                              element.fontFamily === "'Montserrat', sans-serif"
                                ? "selected"
                                : ""
                            }>Montserrat</option>
                            <option value="'Open Sans', sans-serif" ${
                              element.fontFamily === "'Open Sans', sans-serif"
                                ? "selected"
                                : ""
                            }>Open Sans</option>
                            <option value="Arial, sans-serif" ${
                              element.fontFamily === "Arial, sans-serif"
                                ? "selected"
                                : ""
                            }>Arial</option>
                            <option value="'Times New Roman', serif" ${
                              element.fontFamily === "'Times New Roman', serif"
                                ? "selected"
                                : ""
                            }>Times New Roman</option>
                            <option value="'Courier New', monospace" ${
                              element.fontFamily === "'Courier New', monospace"
                                ? "selected"
                                : ""
                            }>Courier New</option>
                        </select>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Font Size</div>
                        <input type="range" min="12" max="120" value="${
                          element.fontSize
                        }" 
                            oninput="updateElement('${element.id}', {fontSize: parseInt(this.value)})">
                        <div class="range-value">${element.fontSize}px</div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Color</div>
                        <input type="color" value="${element.color}" 
                            onchange="updateElement('${element.id}', {color: this.value})">
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Style</div>
                        <div class="style-buttons">
                            <button class="style-btn ${
                              element.fontWeight === "bold" ? "active" : ""
                            }" 
                                onclick="updateElement('${
                                  element.id
                                }', {fontWeight: '${
            element.fontWeight === "bold" ? "normal" : "bold"
          }'})">
                                <strong>B</strong>
                            </button>
                            <button class="style-btn ${
                              element.fontStyle === "italic" ? "active" : ""
                            }" 
                                onclick="updateElement('${
                                  element.id
                                }', {fontStyle: '${
            element.fontStyle === "italic" ? "normal" : "italic"
          }'})">
                                <em>I</em>
                            </button>
                            <button class="style-btn ${
                              element.textTransform === "uppercase"
                                ? "active"
                                : ""
                            }" 
                                onclick="updateElement('${
                                  element.id
                                }', {textTransform: '${
            element.textTransform === "uppercase" ? "none" : "uppercase"
          }'})">
                                Aa
                            </button>
                            <button class="style-btn ${
                              element.textDecoration === "underline"
                                ? "active"
                                : ""
                            }" 
                                onclick="updateElement('${
                                  element.id
                                }', {textDecoration: '${
            element.textDecoration === "underline" ? "none" : "underline"
          }'})">
                                UÃ≤
                            </button>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Text Align</div>
                        <div class="style-buttons">
                            <button class="style-btn ${
                              element.textAlign === "left" ? "active" : ""
                            }" 
                                onclick="updateElement('${element.id}', {textAlign: 'left'})">‚Üê</button>
                            <button class="style-btn ${
                              element.textAlign === "center" ? "active" : ""
                            }" 
                                onclick="updateElement('${element.id}', {textAlign: 'center'})">‚Üî</button>
                            <button class="style-btn ${
                              element.textAlign === "right" ? "active" : ""
                            }" 
                                onclick="updateElement('${element.id}', {textAlign: 'right'})">‚Üí</button>
                            <button class="style-btn ${
                              element.textAlign === "justify" ? "active" : ""
                            }" 
                                onclick="updateElement('${element.id}', {textAlign: 'justify'})">‚é∏‚éπ</button>
                        </div>
                    </div>
                `;
        }

        // Image Properties
        if (element.type === "image") {
          html += `
                    <div class="property-group">
                        <div class="property-label">Border Radius</div>
                        <input type="range" min="0" max="999" value="${
                          element.borderRadius || 0
                        }" 
                            oninput="updateElement('${element.id}', {borderRadius: parseInt(this.value)})">
                        <div class="range-value">${
                          element.borderRadius || 0
                        }px</div>
                    </div>
                    
                    <div class="property-group">
                        <div class="property-label">Border</div>
                        <input type="range" min="0" max="20" value="${
                          element.borderWidth || 0
                        }" 
                            oninput="updateElement('${element.id}', {borderWidth: parseInt(this.value)})">
                        <div class="range-value">${
                          element.borderWidth || 0
                        }px</div>
                        <div class="color-picker-group" style="margin-top:5px;">
                            <span class="color-label">Color:</span>
                            <input type="color" value="${
                              element.borderColor || "#000000"
                            }" 
                                onchange="updateElement('${element.id}', {borderColor: this.value})" style="flex:1;">
                        </div>
                    </div>
                `;
        }

        // Universal Properties
        html += `
                <div class="property-group">
                    <div class="property-label">Opacity</div>
                    <input type="range" min="0" max="1" step="0.1" value="${
                      element.opacity || 1
                    }" 
                        oninput="updateElement('${element.id}', {opacity: parseFloat(this.value)})">
                    <div class="range-value">${Math.round(
                      (element.opacity || 1) * 100,
                    )}%</div>
                </div>
                <div class="property-group">
                    <div class="property-label">Rotation</div>
                    <input type="range" min="0" max="360" value="${
                      element.rotation || 0
                    }" 
                        oninput="updateElement('${element.id}', {rotation: parseInt(this.value)})">
                    <div class="range-value">${element.rotation || 0}¬∞</div>
                </div>
                <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 16px 0; padding-top: 16px;">
                    <button class="action-btn duplicate" onclick="duplicateElement('${element.id}')">üìã Duplicate</button>
                    <button class="action-btn delete" onclick="deleteElement('${element.id}')">üóëÔ∏è Delete</button>
                </div>
            `;

        properties.innerHTML = html;
      }

      // Helper Functions
      function getElementIcon(type) {
        const icons = {
          text: "üìù",
          image: "üñºÔ∏è",
        };
        return icons[type] || "üìÑ";
      }

      function getElementLabel(element) {
        if (element.type === "text") {
          return (
            element.content.substring(0, 20) +
            (element.content.length > 20 ? "..." : "")
          );
        } else if (element.type === "image") {
          return "Image";
        }
        return "Element";
      }

      // Drag & Drop
      function onElementMouseDown(e, id) {
        if (e.target.classList.contains("resize-handle")) return;

        e.preventDefault();
        e.stopPropagation();

        isDragging = true;
        state.selectedElement = id;

        const element = state[state.activeSide].elements.find(
          (el) => el.id === id,
        );
        const canvas = document.getElementById(state.activeSide + "Canvas");
        const rect = canvas.getBoundingClientRect();

        dragStartX = e.clientX - rect.left - element.x;
        dragStartY = e.clientY - rect.top - element.y;

        updateUI();
      }

      function onResizeMouseDown(e, id, corner) {
        e.preventDefault();
        e.stopPropagation();

        isResizing = true;
        state.selectedElement = id;

        const element = state[state.activeSide].elements.find(
          (el) => el.id === id,
        );

        resizeStartData = {
          id,
          corner,
          startX: e.clientX,
          startY: e.clientY,
          startWidth: element.width,
          startHeight: element.height,
          startPosX: element.x,
          startPosY: element.y,
        };
      }

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const canvas = document.getElementById(state.activeSide + "Canvas");
          const rect = canvas.getBoundingClientRect();
          const element = state[state.activeSide].elements.find(
            (el) => el.id === state.selectedElement,
          );

          if (element) {
            let newX = e.clientX - rect.left - dragStartX;
            let newY = e.clientY - rect.top - dragStartY;

            // Constrain within canvas
            newX = Math.max(
              0,
              Math.min(
                newX,
                state[state.activeSide].width - (element.width || 50),
              ),
            );
            newY = Math.max(
              0,
              Math.min(
                newY,
                state[state.activeSide].height - (element.height || 50),
              ),
            );

            element.x = newX;
            element.y = newY;
            renderCanvas();
          }
        } else if (isResizing && resizeStartData) {
          const element = state[state.activeSide].elements.find(
            (el) => el.id === resizeStartData.id,
          );
          if (element) {
            const deltaX = e.clientX - resizeStartData.startX;
            const deltaY = e.clientY - resizeStartData.startY;

            let newWidth = resizeStartData.startWidth;
            let newHeight = resizeStartData.startHeight;
            let newX = resizeStartData.startPosX;
            let newY = resizeStartData.startPosY;

            if (resizeStartData.corner.includes("e")) {
              newWidth = Math.max(30, resizeStartData.startWidth + deltaX);
            }
            if (resizeStartData.corner.includes("s")) {
              newHeight = Math.max(30, resizeStartData.startHeight + deltaY);
            }
            if (resizeStartData.corner.includes("w")) {
              newWidth = Math.max(30, resizeStartData.startWidth - deltaX);
              newX = resizeStartData.startPosX + deltaX;
            }
            if (resizeStartData.corner.includes("n")) {
              newHeight = Math.max(30, resizeStartData.startHeight - deltaY);
              newY = resizeStartData.startPosY + deltaY;
            }

            // Constrain within canvas
            newX = Math.max(
              0,
              Math.min(newX, state[state.activeSide].width - newWidth),
            );
            newY = Math.max(
              0,
              Math.min(newY, state[state.activeSide].height - newHeight),
            );

            element.width = newWidth;
            element.height = newHeight;
            element.x = newX;
            element.y = newY;
            renderCanvas();
          }
        }
      });

      document.addEventListener("mouseup", () => {
        if (isDragging || isResizing) {
          saveToHistory();
        }
        isDragging = false;
        isResizing = false;
        resizeStartData = null;
      });

      // High Quality Download Function
      async function downloadHighQuality(mode) {
        showLoading();

        const currentZoom = zoomLevel;
        zoomLevel = 1;
        updateZoomDisplay();

        const originalSide = state.activeSide;
        const originalSelected = state.selectedElement;

        try {
          // Calculate scale factor for high quality
          const scaleFactor = downloadQuality;

          if (mode === "both") {
            // Download both sides

            // Download front side
            state.activeSide = "front";
            state.selectedElement = null;
            renderCanvas();
            await new Promise((resolve) => setTimeout(resolve, 200));

            updateLoadingText("Processing front side...");
            const frontCanvas = document.getElementById("frontCanvas");
            const frontImage = await html2canvas(frontCanvas, {
              backgroundColor: null,
              scale: scaleFactor,
              logging: false,
              useCORS: true,
              allowTaint: true,
              imageTimeout: 0,
            });

            // Download back side
            state.activeSide = "back";
            state.selectedElement = null;
            renderCanvas();
            await new Promise((resolve) => setTimeout(resolve, 200));

            updateLoadingText("Processing back side...");
            const backCanvas = document.getElementById("backCanvas");
            const backImage = await html2canvas(backCanvas, {
              backgroundColor: null,
              scale: scaleFactor,
              logging: false,
              useCORS: true,
              allowTaint: true,
              imageTimeout: 0,
            });

            updateLoadingText("Creating ZIP file...");
            const zip = new JSZip();

            // Add front image to zip with highest quality
            const frontDataUrl = frontImage.toDataURL("image/png", 1.0);
            const frontBase64 = frontDataUrl.split(",")[1];
            zip.file("id-card-front.png", frontBase64, { base64: true });

            // Add back image to zip with highest quality
            const backDataUrl = backImage.toDataURL("image/png", 1.0);
            const backBase64 = backDataUrl.split(",")[1];
            zip.file("id-card-back.png", backBase64, { base64: true });

            updateLoadingText("Finalizing download...");
            const content = await zip.generateAsync({
              type: "blob",
              compression: "STORE", // No compression for faster processing
              compressionOptions: {
                level: 0,
              },
            });

            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = `id-card-${scaleFactor}x-${Date.now()}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            alert(
              `Both sides downloaded successfully! Quality: ${scaleFactor}x`,
            );
          } else if (mode === "front" || mode === "back") {
            // Download single side
            state.activeSide = mode;
            state.selectedElement = null;
            renderCanvas();
            await new Promise((resolve) => setTimeout(resolve, 200));

            updateLoadingText(`Processing ${mode} side...`);
            const canvas = document.getElementById(mode + "Canvas");
            const image = await html2canvas(canvas, {
              backgroundColor: null,
              scale: scaleFactor,
              logging: false,
              useCORS: true,
              allowTaint: true,
              imageTimeout: 0,
            });

            updateLoadingText("Creating image file...");
            const link = document.createElement("a");
            link.download = `id-card-${mode}-${scaleFactor}x-${Date.now()}.png`;

            // Create blob with maximum quality
            image.toBlob(
              function (blob) {
                const url = URL.createObjectURL(blob);
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                alert(
                  `${mode} side downloaded successfully! Quality: ${scaleFactor}x`,
                );
                hideLoading();
              },
              "image/png",
              1.0,
            );

            return; // Return early for blob download
          }
        } catch (error) {
          console.error("Download error:", error);
          alert(
            "Error downloading canvas. Please try again with lower quality settings.",
          );
        } finally {
          // Restore original state
          state.activeSide = originalSide;
          state.selectedElement = originalSelected;
          zoomLevel = currentZoom;
          updateZoomDisplay();
          renderCanvas();
          hideLoading();
        }
      }

      // Save Template Modal Functions
      function openSaveTemplateModal() {
        console.log("Opening save template modal...");

        // Update modal content with current data
        document.getElementById("currentTemplateId").textContent = tempId;
        document.getElementById("currentAppId").textContent = appId;

        // Calculate total elements
        const totalElements =
          state.front.elements.length + state.back.elements.length;
        document.getElementById("elementCount").textContent = totalElements;

        // Set default template name
        const templateNameInput = document.getElementById("templateNameInput");
        if (originalTemplateData && originalTemplateData.templates) {
          const originalTemplate = originalTemplateData.templates[0];
          if (originalTemplate && originalTemplate.template_name) {
            templateNameInput.value = originalTemplate.template_name + " (Updated)";
          } else {
            templateNameInput.value = `Template ${tempId} (Updated)`;
          }
        } else {
          templateNameInput.value = `Template ${tempId} (Updated)`;
        }

        // Clear any previous errors
        document.getElementById("templateNameError").classList.remove("show");
        templateNameInput.classList.remove("error");

        // Show the modal
        document.getElementById("saveTemplateModal").classList.add("active");
      }

      function closeSaveTemplateModal() {
        document.getElementById("saveTemplateModal").classList.remove("active");
      }

      // Validate save form
      function validateSaveForm() {
        const templateName = document
          .getElementById("templateNameInput")
          .value.trim();
        const errorElement = document.getElementById("templateNameError");

        if (!templateName) {
          document.getElementById("templateNameInput").classList.add("error");
          errorElement.classList.add("show");
          return false;
        }

        return true;
      }

      // Helper function to convert base64 to blob
      function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);
        
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      }

      // Helper function to save local backup with images
      function saveLocalBackupWithImages(templateName, saveOption, frontBase64, backBase64, apiResult) {
        const backupData = {
          app_id: appId,
          tempid: tempId,
          template_name: templateName,
          save_option: saveOption,
          canvasSize: {
            width: state.front.width,
            height: state.front.height,
          },
          elements: {
            front: state.front.elements,
            back: state.back.elements,
          },
          background: {
            front: state.front.background,
            back: state.back.background,
          },
          orientation: state.orientation,
          // Include base64 images (truncated for display, full in separate files)
          base64_images: {
            front: frontBase64 ? frontBase64.substring(0, 500) + "... [TRUNCATED]" : null,
            back: backBase64 ? backBase64.substring(0, 500) + "... [TRUNCATED]" : null,
          },
          savedAt: new Date().toISOString(),
          note: "Local backup - Includes base64 images (truncated in this file)",
          apiResponse: apiResult,
        };

        // Save the main JSON file
        const jsonStr = JSON.stringify(backupData, null, 2);
        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `template-${tempId}-backup-${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        // Optionally save full base64 images to separate files
        if (frontBase64 && frontBase64.length > 0) {
          const frontBlob = base64ToBlob(frontBase64, 'image/png');
          const frontUrl = URL.createObjectURL(frontBlob);
          const frontLink = document.createElement("a");
          frontLink.href = frontUrl;
          frontLink.download = `template-${tempId}-front-image-${Date.now()}.png`;
          document.body.appendChild(frontLink);
          frontLink.click();
          document.body.removeChild(frontLink);
          URL.revokeObjectURL(frontUrl);
        }

        if (backBase64 && backBase64.length > 0) {
          const backBlob = base64ToBlob(backBase64, 'image/png');
          const backUrl = URL.createObjectURL(backBlob);
          const backLink = document.createElement("a");
          backLink.href = backUrl;
          backLink.download = `template-${tempId}-back-image-${Date.now()}.png`;
          document.body.appendChild(backLink);
          backLink.click();
          document.body.removeChild(backLink);
          URL.revokeObjectURL(backUrl);
        }
      }

// Main Save Template Function - WITHOUT local backup
async function saveTemplateUpdates() {
  console.log("üíæ Saving template updates...");

  if (!validateSaveForm()) {
    return;
  }

  showLoading();
  updateLoadingText("Preparing template data for saving...");

  try {
    // Get form values
    const templateName = document
      .getElementById("templateNameInput")
      .value.trim();
    const saveOption = document.querySelector(
      'input[name="saveOption"]:checked'
    ).value;

    // Capture the current canvas as base64 image
    let frontImageBase64 = null;
    let backImageBase64 = null;

    // Save original state
    const originalSide = state.activeSide;
    const originalSelected = state.selectedElement;
    const originalZoom = zoomLevel;

    // Reset zoom for clean capture
    zoomLevel = 1;
    updateZoomDisplay();

    // Determine export type based on save option
    let exportType;
    if (saveOption === "both") exportType = "both";
    else if (saveOption === "front") exportType = "front";
    else if (saveOption === "back") exportType = "back";

    // Process elements for export
    const elementsToExport = {
      front: [],
      back: []
    };

    // Prepare front elements if needed
    if (saveOption === "both" || saveOption === "front") {
      state.front.elements.forEach(element => {
        const elementCopy = JSON.parse(JSON.stringify(element));
        // For images, ensure content is properly formatted
        if (elementCopy.type === "image" && elementCopy.content) {
          // Keep the image data as is (it should already be base64)
          if (elementCopy.content.startsWith("data:image/")) {
            // It's already a data URL, keep it
          } else if (elementCopy.content.length > 100) {
            // Assume it's base64 without prefix
            elementCopy.content = "data:image/png;base64," + elementCopy.content;
          }
        }
        // Add additional properties for your API format
        elementCopy.imageFilter = elementCopy.filter || "none";
        elementCopy.brightness = 100;
        elementCopy.contrast = 100;
        elementCopy.saturate = 100;
        elementCopy.hueRotate = 0;
        elementCopy.blur = 0;
        elementCopy.sepia = 0;
        elementCopy.invert = 0;
        elementCopy.grayscale = 0;
        elementCopy.opacityFilter = 100;
        elementCopy.dropShadow = false;
        elementCopy.shadowColor = "#000000";
        elementCopy.shadowBlur = 10;
        elementCopy.shadowX = 0;
        elementCopy.shadowY = 0;
        elementCopy.blendMode = "normal";
        elementCopy.imageOverlay = false;
        elementCopy.overlayColor = "rgba(0,0,0,0.5)";
        elementCopy.imageMask = "none";
        elementCopy.maskColor = "#000000";
        elementCopy.imageReflection = false;
        elementCopy.reflectionOpacity = 30;
        elementCopy.reflectionDistance = 10;
        elementCopy.imageTilt = 0;
        elementCopy.imageZoom = 100;
        
        elementsToExport.front.push(elementCopy);
      });

      // Capture front canvas image
      state.activeSide = "front";
      state.selectedElement = null;
      renderCanvas();
      await new Promise((resolve) => setTimeout(resolve, 300));

      updateLoadingText("Capturing front side image...");
      const frontCanvas = document.getElementById("frontCanvas");
      
      const frontCanvasImage = await html2canvas(frontCanvas, {
        backgroundColor: null,
        scale: 2,
        logging: false,
        useCORS: true,
        allowTaint: true,
        imageTimeout: 10000,
      });

      frontImageBase64 = frontCanvasImage.toDataURL("image/png");
      console.log("Front image captured, base64 preview:", frontImageBase64.substring(0, 100) + "...");
    }

    // Prepare back elements if needed
    if (saveOption === "both" || saveOption === "back") {
      state.back.elements.forEach(element => {
        const elementCopy = JSON.parse(JSON.stringify(element));
        // For images, ensure content is properly formatted
        if (elementCopy.type === "image" && elementCopy.content) {
          if (elementCopy.content.startsWith("data:image/")) {
            // It's already a data URL, keep it
          } else if (elementCopy.content.length > 100) {
            // Assume it's base64 without prefix
            elementCopy.content = "data:image/png;base64," + elementCopy.content;
          }
        }
        // Add additional properties for your API format
        elementCopy.imageFilter = elementCopy.filter || "none";
        elementCopy.brightness = 100;
        elementCopy.contrast = 100;
        elementCopy.saturate = 100;
        elementCopy.hueRotate = 0;
        elementCopy.blur = 0;
        elementCopy.sepia = 0;
        elementCopy.invert = 0;
        elementCopy.grayscale = 0;
        elementCopy.opacityFilter = 100;
        elementCopy.dropShadow = false;
        elementCopy.shadowColor = "#000000";
        elementCopy.shadowBlur = 10;
        elementCopy.shadowX = 0;
        elementCopy.shadowY = 0;
        elementCopy.blendMode = "normal";
        elementCopy.imageOverlay = false;
        elementCopy.overlayColor = "rgba(0,0,0,0.5)";
        elementCopy.imageMask = "none";
        elementCopy.maskColor = "#000000";
        elementCopy.imageReflection = false;
        elementCopy.reflectionOpacity = 30;
        elementCopy.reflectionDistance = 10;
        elementCopy.imageTilt = 0;
        elementCopy.imageZoom = 100;
        
        elementsToExport.back.push(elementCopy);
      });

      // Capture back canvas image
      state.activeSide = "back";
      state.selectedElement = null;
      renderCanvas();
      await new Promise((resolve) => setTimeout(resolve, 300));

      updateLoadingText("Capturing back side image...");
      const backCanvas = document.getElementById("backCanvas");
      
      const backCanvasImage = await html2canvas(backCanvas, {
        backgroundColor: null,
        scale: 2,
        logging: false,
        useCORS: true,
        allowTaint: true,
        imageTimeout: 10000,
      });

      backImageBase64 = backCanvasImage.toDataURL("image/png");
      console.log("Back image captured, base64 preview:", backImageBase64.substring(0, 100) + "...");
    }

    // Restore original state
    state.activeSide = originalSide;
    state.selectedElement = originalSelected;
    zoomLevel = originalZoom;
    updateZoomDisplay();
    renderCanvas();

    // Prepare the complete payload in your specified format
    const payload = {
      app_id: appId,
      tempid: tempId,
      action: "edit",
      exportData: {
        accessType: "all",
        templateName: templateName,
        service: "ID Card",
        exportType: exportType
      },
      elements: {
        front: elementsToExport.front,
        back: saveOption === "both" ? elementsToExport.back : []
      },
      canvasSize: {
        width: state.front.width,
        height: state.front.height
      },
      version: "1.0.0",
      exportDate: new Date().toISOString(),
      sentToAPI: false,
      timestamp: new Date().toISOString(),
      // Add the base64 images
      templateFrontImage: frontImageBase64 || "",
      templateBackImage: backImageBase64 || ""
    };

    console.log("üì§ Sending update to API in specified format...");
    console.log("Payload structure:", JSON.stringify(payload, null, 2).substring(0, 500) + "...");

    updateLoadingText("Saving to database with images...");

    // Send to API
    const response = await fetch(UPDATE_TEMPLATE_API, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify(payload),
    });

    console.log("üì• API Response status:", response.status);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const responseText = await response.text();
    console.log("üì• Raw response:", responseText.substring(0, 500) + "...");

    // Try to parse JSON response
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (parseError) {
      console.warn("Response is not valid JSON, treating as plain text:", responseText);
      
      // Check if response contains success indicators (even if not JSON)
      if (responseText.toLowerCase().includes("success") || 
          responseText.toLowerCase().includes("updated") ||
          responseText.toLowerCase().includes("saved") ||
          response.status === 200) {
        
        // Treat as successful even if not JSON
        result = {
          success: true,
          message: responseText,
          status: "success"
        };
      } else {
        throw new Error(`API returned non-JSON response: ${responseText}`);
      }
    }

    console.log("‚úÖ API Response:", result);

    // Check if update was successful - handle multiple success indicators
    if (result.success === true || 
        result.status === "success" || 
        result.status === "updated" ||
        (result.message && (result.message.toLowerCase().includes("success") || 
                            result.message.toLowerCase().includes("updated") ||
                            result.message.toLowerCase().includes("saved"))) ||
        response.ok) {
      
      closeSaveTemplateModal();
      hideLoading();

      alert(
        `‚úÖ Template updated successfully!\n\n` +
        `Server response: ${result.message || responseText || "Template updated"}\n\n` +
        `The template has been saved with all elements and images.`
      );

      // Optionally refresh the page to show updated data
      setTimeout(() => {
        window.location.reload();
      }, 2000);
      
    } else {
      // If we have a message but it's not a success, show it
      if (result.message) {
        throw new Error(result.message);
      } else {
        throw new Error("Update failed with unknown error");
      }
    }
  } catch (error) {
    console.error("‚ùå Save error:", error);
    hideLoading();

    // Check if the error message actually indicates success
    const errorMessage = error.message || error.toString();
    
    if (errorMessage.toLowerCase().includes("updated") ||
        errorMessage.toLowerCase().includes("success") ||
        errorMessage.toLowerCase().includes("saved")) {
      
      // It was actually successful!
      alert(
        `‚úÖ Template updated successfully!\n\n` +
        `Server message: ${errorMessage}\n\n` +
        `The template has been saved successfully.`
      );
      
      closeSaveTemplateModal();
      
      // Optionally refresh
      setTimeout(() => {
        window.location.reload();
      }, 2000);
      
    } else {
      // It's a real error
      alert(
        `‚ùå Failed to save template:\n\n` +
        `${errorMessage}\n\n` +
        `Please try again or check your connection.`
      );
    }
  }
}

// Remove the saveLocalBackup function completely

// Updated local backup function for the new format
// function saveLocalBackup(payload, apiResult) {
//   const backupData = {
//     ...payload,
//     savedAt: new Date().toISOString(),
//     note: "Local backup - Data in API format",
//     apiResponse: apiResult,
//   };

//   // Truncate base64 images for the JSON file to keep it manageable
//   if (backupData.templateFrontImage && backupData.templateFrontImage.length > 500) {
//     backupData.templateFrontImage = backupData.templateFrontImage.substring(0, 500) + "... [TRUNCATED]";
//   }
//   if (backupData.templateBackImage && backupData.templateBackImage.length > 500) {
//     backupData.templateBackImage = backupData.templateBackImage.substring(0, 500) + "... [TRUNCATED]";
//   }

//   // Save the main JSON file
//   const jsonStr = JSON.stringify(backupData, null, 2);
//   const blob = new Blob([jsonStr], { type: "application/json" });
//   const url = URL.createObjectURL(blob);
//   const link = document.createElement("a");
//   link.href = url;
//   link.download = `template-${tempId}-api-format-${Date.now()}.json`;
//   document.body.appendChild(link);
//   link.click();
//   document.body.removeChild(link);
//   URL.revokeObjectURL(url);

//   alert(
//     `‚úÖ Local backup saved successfully!\n\nFile: ${link.download}\n\nData saved in API format with:\n` +
//     `‚Ä¢ exportData section\n` +
//     `‚Ä¢ Enhanced element properties\n` +
//     `‚Ä¢ Full metadata\n` +
//     `‚Ä¢ Template images (truncated in JSON)`
//   );
// }

      // Loading overlay functions
      function showLoading() {
        document.getElementById("loadingOverlay").style.display = "flex";
      }

      function hideLoading() {
        document.getElementById("loadingOverlay").style.display = "none";
      }

      function updateLoadingText(text) {
        document.getElementById("loadingDetails").textContent = text;
      }

      // Initialize the app
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("üöÄ DOM Content Loaded - Starting initialization");
        await init();
        console.log("‚úÖ App initialization complete");
      });
    </script>
  </body>
</html>